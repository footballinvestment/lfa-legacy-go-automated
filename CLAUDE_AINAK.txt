🔍 OPTIMALIZÁLT LFA LEGACY GO TUDÁSTÁR GYŰJTÉS
================================================
📅 Generálás ideje: 2025 Sze  5 Pén 09:31:30 CEST
🎯 Csak kritikus forráskódok

==== PROJEKT FŐKÖNYVTÁR STRUKTÚRA ====
.
├── \033[0;32m[SUCCESS]\033[0m Created directory: CLAUDE_AINAK\012CLAUDE_AINAK
├── \033[1;33m[WARNING]\033[0m Directory 'CLAUDE_AINAK' already exists. Cleaning it...\012\033[0;32m[SUCCESS]\033[0m Created directory: CLAUDE_AINAK\012CLAUDE_AINAK
│   ├── backend
│   ├── docs
│   ├── frontend
│   ├── migrations
│   ├── test
│   └── tests
├── automation-diagnostics
├── backend
│   ├── \033[1;33m[WARNING]\033[0m Directory 'CLAUDE_AINAK' already exists. Cleaning it...\012\033[0;32m[SUCCESS]\033[0m Created directory: CLAUDE_AINAK\012CLAUDE_AINAK
│   │   └── backend
│   ├── app
│   │   ├── core
│   │   ├── middleware
│   │   ├── models
│   │   ├── routers
│   │   ├── schemas
│   │   ├── services
│   │   ├── utils
│   │   ├── validators
│   │   └── websocket
│   ├── backend
│   │   └── venv_new
│   ├── docs
│   ├── migrations
│   ├── scripts
│   ├── venv
│   │   ├── bin
│   │   ├── include
│   │   └── lib
│   ├── venv_test
│   │   ├── bin
│   │   ├── include
│   │   └── lib
│   └── working_env
│       ├── bin
│       ├── include
│       └── lib
├── build-manual
├── documentation
├── docs
│   └── \033[1;33m[WARNING]\033[0m Directory 'CLAUDE_AINAK' already exists. Cleaning it...\012\033[0;32m[SUCCESS]\033[0m Created directory: CLAUDE_AINAK\012CLAUDE_AINAK
│       └── docs
├── frontend
│   ├── \033[1;33m[WARNING]\033[0m Directory 'CLAUDE_AINAK' already exists. Cleaning it...\012\033[0;32m[SUCCESS]\033[0m Created directory: CLAUDE_AINAK\012CLAUDE_AINAK
│   │   └── frontend
│   ├── e2e
│   ├── public
│   ├── src
│   │   ├── __tests__
│   │   ├── components
│   │   ├── config
│   │   ├── contexts
│   │   ├── hooks
│   │   ├── pages
│   │   ├── services
│   │   ├── styles
│   │   ├── theme
│   │   ├── types
│   │   └── utils
│   └── tests
│       └── e2e
├── migrations
│   └── \033[1;33m[WARNING]\033[0m Directory 'CLAUDE_AINAK' already exists. Cleaning it...\012\033[0;32m[SUCCESS]\033[0m Created directory: CLAUDE_AINAK\012CLAUDE_AINAK
│       └── migrations
├── screenshots
├── terraform
├── test
│   └── \033[1;33m[WARNING]\033[0m Directory 'CLAUDE_AINAK' already exists. Cleaning it...\012\033[0;32m[SUCCESS]\033[0m Created directory: CLAUDE_AINAK\012CLAUDE_AINAK
│       └── test
├── tests
│   ├── \033[1;33m[WARNING]\033[0m Directory 'CLAUDE_AINAK' already exists. Cleaning it...\012\033[0;32m[SUCCESS]\033[0m Created directory: CLAUDE_AINAK\012CLAUDE_AINAK
│   │   └── tests
│   └── automation
└── venv
    ├── bin
    ├── include
    │   ├── python3.11
    │   └── python3.13
    └── lib
        ├── python3.11
        └── python3.13

84 directories

🐍 BACKEND CORE KOMPONENSEK
==============================

==== Backend Dependencies ==== (backend/requirements.txt)
fastapi==0.104.1
uvicorn[standard]==0.24.0
sqlalchemy==2.0.23
psycopg2-binary==2.9.9
python-jose[cryptography]==3.3.0
python-multipart==0.0.6
passlib[bcrypt]==1.7.4
pydantic==2.5.2
pydantic-settings==2.1.0
python-dotenv==1.0.0
aiofiles==23.2.1
emails==0.6.0
pyotp==2.9.0
qrcode[pil]==7.4.2
argon2-cffi==23.1.0
aiohttp==3.9.1
Pillow==10.1.0
httpx==0.25.2
redis==5.0.1
jinja2==3.1.2
sendgrid==6.10.0

⚛️  FRONTEND CORE KOMPONENSEK
==============================

==== Frontend Dependencies ==== (frontend/package.json)
{
  "name": "lfa-legacy-go-frontend",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "@fontsource/roboto": "^5.0.8",
    "@tanstack/react-query": "^5.8.4",
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "@types/jest": "^27.5.2",
    "@types/node": "^16.18.59",
    "date-fns": "^2.30.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "recharts": "^2.15.4",
    "typescript": "^4.9.5",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "NODE_OPTIONS=\"--max-old-space-size=16384\" GENERATE_SOURCEMAP=false DISABLE_ESLINT_PLUGIN=true TSC_COMPILE_ON_ERROR=true SKIP_PREFLIGHT_CHECK=true FAST_REFRESH=false craco start",
    "start:minimal": "NODE_OPTIONS=\"--max-old-space-size=4096\" SKIP_PREFLIGHT_CHECK=true TSC_COMPILE_ON_ERROR=true DISABLE_ESLINT_PLUGIN=true GENERATE_SOURCEMAP=false FAST_REFRESH=false craco start",
    "start:ultralow": "NODE_OPTIONS=\"--max-old-space-size=4096\" SKIP_PREFLIGHT_CHECK=true TSC_COMPILE_ON_ERROR=true DISABLE_ESLINT_PLUGIN=true GENERATE_SOURCEMAP=false FAST_REFRESH=false WDS_SOCKET_PORT=0 craco start",
    "build": "NODE_OPTIONS=\"--max-old-space-size=32768\" GENERATE_SOURCEMAP=false react-scripts build",
    "test": "react-scripts test",
    "test:e2e": "npx playwright test",
    "test:e2e:ui": "npx playwright test --ui",
    "test:e2e:debug": "npx playwright test --debug",
    "test:e2e:headed": "npx playwright test --headed",
    "test:e2e:report": "npx playwright show-report",
    "eject": "react-scripts eject",
    "dev": "NODE_OPTIONS='--max-old-space-size=8192' GENERATE_SOURCEMAP=false react-scripts start",
    "start:memory": "NODE_OPTIONS=\"--max-old-space-size=20480\" GENERATE_SOURCEMAP=false react-scripts start",
    "lint": "eslint src/ --ext .js,.jsx,.ts,.tsx",
    "lint:fix": "eslint src/ --ext .js,.jsx,.ts,.tsx --fix",
    "format": "prettier --write src/",
    "format:check": "prettier --check src/",
    "type-check": "NODE_OPTIONS='--max-old-space-size=4096' tsc --noEmit",
    "analyze": "npm run build && npx source-map-explorer 'build/static/js/*.js'",
    "bundle:size": "npm run build && ls -lh build/static/js/main.*.js",
    "bundle:gzip": "npm run build && gzip -9 -c build/static/js/main.*.js | wc -c"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest",
      "prettier"
    ],
    "plugins": [
      "prettier"
    ],
    "rules": {
      "prettier/prettier": "warn",
      "no-console": "warn",
      "@typescript-eslint/no-unused-vars": "warn",
      "react/jsx-props-no-spreading": "off",
      "react/prop-types": "off"
    }
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@craco/craco": "^7.1.0",
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "@mui/icons-material": "^7.3.1",
    "@mui/lab": "^7.0.0-beta.16",
    "@mui/material": "^7.3.1",
    "@mui/x-date-pickers": "^8.10.0",
    "@playwright/test": "^1.54.2",
    "@types/react": "^19.1.10",
    "@types/react-dom": "^19.1.7",
    "@types/react-router-dom": "^5.3.3",
    "ajv": "^8.17.1",
    "ajv-keywords": "^5.1.0",
    "axios": "^1.11.0",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-prettier": "^5.5.4",
    "prettier": "^3.6.2",
    "react-router-dom": "^6.30.1",
    "source-map-explorer": "^2.5.3",
    "webpack-bundle-analyzer": "^4.10.2"
  }
}


==== Main React App ==== (frontend/src/App.tsx)
// LFA Legacy GO - Full Application Rebuild
import React from "react";
import {
  BrowserRouter as Router,
  Routes,
  Route,
  Navigate,
} from "react-router-dom";
import { ThemeProvider, CssBaseline } from "@mui/material";
import { lightAppTheme } from "./styles/theme";
import {
  SafeAuthProvider,
  ProtectedRoute,
  PublicRoute,
} from "./SafeAuthContext";

// Import all original pages
import Login from "./pages/Login";
import SimpleDashboard from "./components/dashboard";
import Tournaments from "./pages/Tournaments";
import Profile from "./pages/Profile";
import CreditsPage from "./pages/CreditsPage";
import Social from "./pages/Social";
import TournamentDetails from "./pages/TournamentDetails";
import GameResults from "./pages/GameResults";
import AdminPanel from "./pages/AdminPanel";
import VerifyEmail from "./pages/VerifyEmail";
import Layout from "./components/layout/Layout";

function App() {
  console.log("🔴 APP COMPONENT MOUNTING");
  console.log("🔴 About to render SafeAuthProvider");
  console.log("🔴 SafeAuthProvider import:", { SafeAuthProvider });
  console.log("🔴 React version:", React.version);
  
  return (
    <ThemeProvider theme={lightAppTheme}>
      <CssBaseline />
      <SafeAuthProvider>
        <Router>
          <Routes>
            {/* Public Routes */}
            <Route
              path="/login"
              element={
                <PublicRoute>
                  <Login />
                </PublicRoute>
              }
            />
            <Route path="/verify-email" element={<VerifyEmail />} />

            {/* Protected Routes with Layout */}
            <Route
              path="/dashboard"
              element={
                <ProtectedRoute>
                  <Layout>
                    <SimpleDashboard />
                  </Layout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/tournaments"
              element={
                <ProtectedRoute>
                  <Layout>
                    <Tournaments />
                  </Layout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/tournaments/:tournamentId"
              element={
                <ProtectedRoute>
                  <Layout>
                    <TournamentDetails />
                  </Layout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/profile"
              element={
                <ProtectedRoute>
                  <Layout>
                    <Profile />
                  </Layout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/credits"
              element={
                <ProtectedRoute>
                  <Layout>
                    <CreditsPage />
                  </Layout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/social"
              element={
                <ProtectedRoute>
                  <Layout>
                    <Social />
                  </Layout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/game-results"
              element={
                <ProtectedRoute>
                  <Layout>
                    <GameResults />
                  </Layout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/admin"
              element={
                <ProtectedRoute>
                  <Layout>
                    <AdminPanel />
                  </Layout>
                </ProtectedRoute>
              }
            />

            {/* Default Routes */}
            <Route path="/" element={<Navigate to="/dashboard" replace />} />
            <Route path="*" element={<Navigate to="/login" replace />} />
          </Routes>
        </Router>
      </SafeAuthProvider>
    </ThemeProvider>
  );
}

export default App;
/* Cache bust: 2025 Sze  4 Csü 16:37:31 CEST */
/* FORCE REBUILD 1757012852 */


==== React Entry Point ==== (frontend/src/index.tsx)
// src/index.tsx
// LFA Legacy GO - Performance Optimized Entry Point

console.log("Index.tsx loading...");

import React from "react";
import { createRoot } from "react-dom/client";

console.log("React import:", typeof React);
console.log("ReactDOM import:", typeof createRoot);

// Force React to be available globally
if (typeof window !== 'undefined') {
  (window as any).React = React;
  console.log("React forced to window");
}

// Environment debug logging (production ready)
console.log("🔧 Environment loaded:", process.env.NODE_ENV);
import "./index.css";
import App from "./App";
import { setupGlobalErrorHandlers } from "./utils/errorHandler";
import { performanceMonitor } from "./utils/performanceMonitor";
import { memoryMonitor } from "./utils/memoryMonitor";
import { verifyAPIConnectivity } from "./utils/apiTest";
import ErrorBoundary from "./components/ErrorBoundary";

console.log("🚀 LFA Legacy GO - Performance Optimized");
console.log("Build timestamp:", new Date().toISOString());

// Setup global error handlers
setupGlobalErrorHandlers();

// Initialize performance monitoring
performanceMonitor.startMonitoring();

// Initialize memory monitoring in development
if (process.env.NODE_ENV === "development") {
  memoryMonitor.startMonitoring();
  console.log("🧠 Memory monitoring enabled for development");

  // Log memory stats every 5 seconds in development
  setInterval(() => {
    const stats = memoryMonitor.getMemoryStats();
    if (stats?.current) {
      console.log(
        `🧠 Memory: ${Math.round(stats.current.usedJSHeapSize / 1024 / 1024)}MB used`
      );
    }
  }, 5000);
}

// Initialize API connectivity test
verifyAPIConnectivity()
  .then((success) => {
    console.log(
      success ? "✅ API connectivity verified" : "❌ API connectivity failed"
    );
  })
  .catch((error) => {
    console.error("❌ API connectivity test failed:", error);
  });

const container = document.getElementById("root");
const root = createRoot(container!);

root.render(
  <React.StrictMode>
    <ErrorBoundary>
      <App />
    </ErrorBoundary>
  </React.StrictMode>
);


==== React Context: AuthContext.tsx ==== (frontend/src/contexts/AuthContext.tsx)
// === frontend/src/contexts/AuthContext.tsx ===
// CLEAN AUTH CONTEXT - NO MOCK ADMIN LOGIC

import React, {
  createContext,
  useContext,
  useReducer,
  useEffect,
  ReactNode,
} from "react";
import { Navigate } from "react-router-dom";
import { authService, RegisterRequest, User } from "../services/api";

// ✅ RegisterData interface
export interface RegisterData {
  username: string;
  password: string;
  email: string;
  full_name: string; // ✅ REQUIRED FIELD
  name?: string; // Optional backward compatibility
}

export interface LoginData {
  username: string;
  password: string;
}

export interface AuthState {
  user: User | null;
  loading: boolean;
  error: string | null;
  isAuthenticated: boolean;
  sessionExpiry: Date | null;
}

type AuthAction =
  | { type: "AUTH_START" }
  | { type: "AUTH_SUCCESS"; payload: User }
  | { type: "AUTH_FAILURE"; payload: string }
  | { type: "AUTH_LOGOUT" }
  | { type: "UPDATE_USER"; payload: Partial<User> }
  | { type: "SET_SESSION_EXPIRY"; payload: Date }
  | { type: "CLEAR_ERROR" };

const initialState: AuthState = {
  user: null,
  loading: false,
  error: null,
  isAuthenticated: false,
  sessionExpiry: null,
};

function authReducer(state: AuthState, action: AuthAction): AuthState {
  switch (action.type) {
    case "AUTH_START":
      return {
        ...state,
        loading: true,
        error: null,
      };
    case "AUTH_SUCCESS":
      return {
        ...state,
        loading: false,
        error: null,
        user: action.payload,
        isAuthenticated: true,
      };
    case "AUTH_FAILURE":
      return {
        ...state,
        loading: false,
        error: action.payload,
        user: null,
        isAuthenticated: false,
      };
    case "AUTH_LOGOUT":
      return {
        ...initialState,
      };
    case "UPDATE_USER":
      return {
        ...state,
        user: state.user ? { ...state.user, ...action.payload } : null,
      };
    case "SET_SESSION_EXPIRY":
      return {
        ...state,
        sessionExpiry: action.payload,
      };
    case "CLEAR_ERROR":
      return {
        ...state,
        error: null,
      };
    default:
      return state;
  }
}

interface AuthContextType {
  state: AuthState;
  login: (data: LoginData) => Promise<boolean>;
  register: (data: RegisterData) => Promise<boolean>;
  logout: () => Promise<void>;
  updateUser: (userData: Partial<User>) => void;
  clearError: () => void;
  refreshStats: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};

interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [state, dispatch] = useReducer(authReducer, initialState);

  // Initialize auth state from stored token
  useEffect(() => {
    const initializeAuth = async () => {
      const token = localStorage.getItem("auth_token");
      if (token) {
        try {
          dispatch({ type: "AUTH_START" });

          // ✅ CRITICAL FIX: Add timeout to prevent infinite loading
          const timeoutPromise = new Promise((_, reject) =>
            setTimeout(
              () => reject(new Error("Auth timeout after 10 seconds")),
              10000
            )
          );

          // Race between API call and timeout
          let userData;
          try {
            userData = await Promise.race([
              authService.getCurrentUser(),
              timeoutPromise,
            ]);
          } catch (error) {
            console.error("Auth initialization failed:", error);
            throw new Error("Authentication timeout or failed");
          }

          // CRITICAL FIX: Proper validation to prevent React Error #130
          if (
            !userData ||
            typeof userData !== "object" ||
            userData.constructor === Error ||
            userData.message
          ) {
            console.error("Invalid user data type:", typeof userData, userData);
            throw new Error(
              "Invalid user data received - got: " + typeof userData
            );
          }

          const user: User = {
            ...userData,
            display_name: userData.display_name,
            bio: userData.bio,
            games_lost: userData.games_lost,
            challenge_wins: userData.challenge_wins,
            challenge_losses: userData.challenge_losses,
            is_premium: userData.is_premium ?? false,
            premium_expires_at: userData.premium_expires_at,
            last_activity: userData.last_activity,
            is_admin: userData.user_type === "admin" || userData.user_type === "moderator", // Add is_admin based on user_type
          };

          dispatch({ type: "AUTH_SUCCESS", payload: user });

          // Calculate session expiry from JWT token
          try {
            const tokenData = JSON.parse(atob(token.split(".")[1]));
            const expiry = new Date(tokenData.exp * 1000);
            dispatch({ type: "SET_SESSION_EXPIRY", payload: expiry });
          } catch (e) {
            // If token parsing fails, set default expiry
            const expiry = new Date();
            expiry.setHours(expiry.getHours() + 12);
            dispatch({ type: "SET_SESSION_EXPIRY", payload: expiry });
          }
        } catch (error) {
          console.error("Auth initialization failed:", error);
          localStorage.removeItem("auth_token");
          dispatch({ type: "AUTH_FAILURE", payload: "Session expired" });
        }
      } else {
        dispatch({ type: "AUTH_FAILURE", payload: "" });
      }
    };

    initializeAuth();
  }, []);

  // ✅ CRITICAL FIX: Fallback timeout to force loading state to false
  useEffect(() => {
    const fallbackTimeout = setTimeout(() => {
      console.warn(
        "⚠️ Auth initialization timeout - forcing loading state to false"
      );
      dispatch({ type: "AUTH_FAILURE", payload: "Authentication timeout" });
    }, 15000);

    return () => clearTimeout(fallbackTimeout);
  }, []);

  const login = async (data: LoginData): Promise<boolean> => {
    try {
      dispatch({ type: "AUTH_START" });

      // ✅ CLEAN: Only real API login
      const response = await authService.login(data);

      localStorage.setItem("auth_token", response.access_token);

      const user: User = {
        ...response.user,
        display_name: response.user.display_name,
        bio: response.user.bio,
        games_lost: response.user.games_lost,
        challenge_wins: response.user.challenge_wins,
        challenge_losses: response.user.challenge_losses,
        is_premium: response.user.is_premium ?? false,
        premium_expires_at: response.user.premium_expires_at,
        last_activity: response.user.last_activity,
        is_admin: response.user.user_type === "admin" || response.user.user_type === "moderator", // Add is_admin based on user_type
      };

      dispatch({ type: "AUTH_SUCCESS", payload: user });

      // Set session expiry
      const expiry = new Date();
      expiry.setTime(expiry.getTime() + response.expires_in * 1000);
      dispatch({ type: "SET_SESSION_EXPIRY", payload: expiry });

      return true;
    } catch (error: any) {
      const errorMessage =
        error.response?.data?.detail || error.message || "Login failed";
      dispatch({ type: "AUTH_FAILURE", payload: errorMessage });
      return false;
    }
  };

  const register = async (data: RegisterData): Promise<boolean> => {
    try {
      dispatch({ type: "AUTH_START" });

      // ✅ Validation
      if (!data.full_name || data.full_name.trim().length === 0) {
        throw new Error("Full name is required");
      }

      const response = await authService.register(data);

      localStorage.setItem("auth_token", response.access_token);

      const user: User = {
        ...response.user,
        display_name: response.user.display_name,
        bio: response.user.bio,
        games_lost: response.user.games_lost,
        challenge_wins: response.user.challenge_wins,
        challenge_losses: response.user.challenge_losses,
        is_premium: response.user.is_premium ?? false,
        premium_expires_at: response.user.premium_expires_at,
        last_activity: response.user.last_activity,
        is_admin: response.user.user_type === "admin" || response.user.user_type === "moderator", // Add is_admin based on user_type
      };

      dispatch({ type: "AUTH_SUCCESS", payload: user });

      const expiry = new Date();
      expiry.setTime(expiry.getTime() + response.expires_in * 1000);
      dispatch({ type: "SET_SESSION_EXPIRY", payload: expiry });

      return true;
    } catch (error: any) {
      const errorMessage =
        error.response?.data?.detail || error.message || "Registration failed";
      dispatch({ type: "AUTH_FAILURE", payload: errorMessage });
      return false;
    }
  };

  const logout = async (): Promise<void> => {
    try {
      // ✅ CLEAN: Only real API logout
      await authService.logout();
    } catch (error) {
      console.error("Logout API call failed:", error);
    } finally {
      localStorage.removeItem("auth_token");
      dispatch({ type: "AUTH_LOGOUT" });
    }
  };

  const updateUser = (userData: Partial<User>): void => {
    dispatch({ type: "UPDATE_USER", payload: userData });
  };

  const clearError = (): void => {
    dispatch({ type: "CLEAR_ERROR" });
  };

  const refreshStats = async (): Promise<void> => {
    const token = localStorage.getItem("auth_token");

    if (!token) return;

    try {
      // ✅ CLEAN: Only real API refresh
      const userData = await authService.getCurrentUser();
      dispatch({ type: "UPDATE_USER", payload: userData });
    } catch (error) {
      console.error("Failed to refresh user stats:", error);
    }
  };

  return (
    <AuthContext.Provider
      value={{
        state,
        login,
        register,
        logout,
        updateUser,
        clearError,
        refreshStats,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

// Protected Route Component
export const ProtectedRoute: React.FC<{ children: ReactNode }> = ({
  children,
}) => {
  const { state } = useAuth();

  if (state.loading) {
    return <div>Loading...</div>;
  }

  if (!state.isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  return <>{children}</>;
};

// Public Route Component (redirects to dashboard if authenticated)
export const PublicRoute: React.FC<{ children: ReactNode }> = ({
  children,
}) => {
  const { state } = useAuth();

  if (state.loading) {
    return <div>Loading...</div>;
  }

  if (state.isAuthenticated) {
    return <Navigate to="/dashboard" replace />;
  }

  return <>{children}</>;
};


==== React Context: SearchContext.tsx ==== (frontend/src/contexts/SearchContext.tsx)
import React, {
  createContext,
  useContext,
  useState,
  useCallback,
  useEffect,
  ReactNode,
} from "react";
import {
  SearchCriteria,
  SearchResponse,
  SearchResult,
  SavedSearch,
  SearchHistory,
  SearchSuggestion,
  SearchCategory,
  FilterSchema,
  FilterBuilderGroup,
} from "../types/search";

// Default search criteria
const defaultSearchCriteria: SearchCriteria = {
  query: "",
  category: "all",
  filters: [],
  sortBy: "relevance",
  sortOrder: "desc",
  tags: [],
};

// Search context interface
export interface SearchContextType {
  // Search state
  criteria: SearchCriteria;
  results: SearchResponse | null;
  isSearching: boolean;
  error: string | null;

  // Search actions
  setCriteria: (criteria: Partial<SearchCriteria>) => void;
  updateQuery: (query: string) => void;
  updateCategory: (category: SearchCategory) => void;
  addFilter: (field: string, operator: string, value: any) => void;
  removeFilter: (filterId: string) => void;
  clearFilters: () => void;
  executeSearch: () => Promise<void>;
  clearSearch: () => void;

  // Saved searches
  savedSearches: SavedSearch[];
  saveCurrentSearch: (name: string) => Promise<void>;
  loadSavedSearch: (searchId: string) => void;
  deleteSavedSearch: (searchId: string) => void;

  // Search history
  searchHistory: SearchHistory[];
  clearHistory: () => void;

  // Suggestions
  suggestions: SearchSuggestion[];
  getSuggestions: (query: string) => Promise<SearchSuggestion[]>;

  // Filter builder
  filterBuilder: FilterBuilderGroup | null;
  setFilterBuilder: (group: FilterBuilderGroup | null) => void;
  applyFilterBuilder: () => void;

  // Schema for dynamic filter building
  filterSchema: FilterSchema;
}

// Create context
const SearchContext = createContext<SearchContextType | undefined>(undefined);

// Search provider component
interface SearchProviderProps {
  children: ReactNode;
}

export const SearchProvider: React.FC<SearchProviderProps> = ({ children }) => {
  // Core search state
  const [criteria, setCriteriaState] = useState<SearchCriteria>(
    defaultSearchCriteria
  );
  const [results, setResults] = useState<SearchResponse | null>(null);
  const [isSearching, setIsSearching] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Extended search state
  const [savedSearches, setSavedSearches] = useState<SavedSearch[]>([]);
  const [searchHistory, setSearchHistory] = useState<SearchHistory[]>([]);
  const [suggestions, setSuggestions] = useState<SearchSuggestion[]>([]);
  const [filterBuilder, setFilterBuilder] = useState<FilterBuilderGroup | null>(
    null
  );

  // Filter schema for different search categories
  const filterSchema: FilterSchema = {
    tournaments: {
      name: {
        label: "Tournament Name",
        type: "text",
        operators: ["contains", "starts_with", "ends_with", "equals"],
      },
      status: {
        label: "Status",
        type: "select",
        operators: ["equals", "in"],
        options: [
          { value: "upcoming", label: "Upcoming" },
          { value: "active", label: "Active" },
          { value: "completed", label: "Completed" },
          { value: "cancelled", label: "Cancelled" },
        ],
      },
      entry_fee: {
        label: "Entry Fee",
        type: "range",
        operators: ["between", "less_than", "greater_than"],
        validation: { min: 0, max: 1000 },
      },
      start_date: {
        label: "Start Date",
        type: "date",
        operators: ["equals", "greater_than", "less_than", "between"],
      },
      skill_level: {
        label: "Skill Level",
        type: "select",
        operators: ["equals", "in"],
        options: [
          { value: "beginner", label: "Beginner" },
          { value: "intermediate", label: "Intermediate" },
          { value: "advanced", label: "Advanced" },
          { value: "professional", label: "Professional" },
        ],
      },
      participants: {
        label: "Participants",
        type: "range",
        operators: ["between", "less_than", "greater_than"],
        validation: { min: 2, max: 100 },
      },
      location: {
        label: "Location",
        type: "location",
        operators: ["contains", "equals"],
      },
      tags: {
        label: "Tags",
        type: "tags",
        operators: ["contains", "in"],
      },
    },
    users: {
      username: {
        label: "Username",
        type: "text",
        operators: ["contains", "starts_with", "equals"],
      },
      full_name: {
        label: "Full Name",
        type: "text",
        operators: ["contains", "starts_with", "equals"],
      },
      level: {
        label: "Level",
        type: "range",
        operators: ["between", "greater_than", "less_than"],
        validation: { min: 1, max: 100 },
      },
      games_played: {
        label: "Games Played",
        type: "range",
        operators: ["between", "greater_than", "less_than"],
        validation: { min: 0 },
      },
      join_date: {
        label: "Join Date",
        type: "date",
        operators: ["equals", "greater_than", "less_than", "between"],
      },
    },
    locations: {
      name: {
        label: "Location Name",
        type: "text",
        operators: ["contains", "starts_with", "equals"],
      },
      city: {
        label: "City",
        type: "text",
        operators: ["contains", "equals"],
      },
      type: {
        label: "Type",
        type: "select",
        operators: ["equals", "in"],
        options: [
          { value: "field", label: "Field" },
          { value: "arena", label: "Arena" },
          { value: "complex", label: "Complex" },
          { value: "park", label: "Park" },
        ],
      },
    },
  };

  // Load saved data from localStorage
  useEffect(() => {
    const loadSavedData = () => {
      try {
        const savedSearchesData = localStorage.getItem("lfa-saved-searches");
        if (savedSearchesData) {
          setSavedSearches(JSON.parse(savedSearchesData));
        }

        const historyData = localStorage.getItem("lfa-search-history");
        if (historyData) {
          setSearchHistory(JSON.parse(historyData));
        }
      } catch (error) {
        console.error("Failed to load search data:", error);
      }
    };

    loadSavedData();
  }, []);

  // Save data to localStorage
  const saveToPersistence = useCallback((key: string, data: any) => {
    try {
      localStorage.setItem(key, JSON.stringify(data));
    } catch (error) {
      console.error(`Failed to save ${key}:`, error);
    }
  }, []);

  // Update search criteria
  const setCriteria = useCallback((newCriteria: Partial<SearchCriteria>) => {
    setCriteriaState((prev) => ({ ...prev, ...newCriteria }));
  }, []);

  // Update query
  const updateQuery = useCallback(
    (query: string) => {
      setCriteria({ query });
    },
    [setCriteria]
  );

  // Update category
  const updateCategory = useCallback(
    (category: SearchCategory) => {
      setCriteria({ category, filters: [] }); // Clear filters when changing category
    },
    [setCriteria]
  );

  // Add filter
  const addFilter = useCallback(
    (field: string, operator: string, value: any) => {
      const newFilter = {
        id: `${field}_${operator}_${Date.now()}`,
        type: "text" as const,
        field,
        operator: operator as any,
        value,
        label: `${field} ${operator} ${value}`,
      };

      setCriteria({
        filters: [...criteria.filters, newFilter],
      });
    },
    [criteria.filters, setCriteria]
  );

  // Remove filter
  const removeFilter = useCallback(
    (filterId: string) => {
      setCriteria({
        filters: criteria.filters.filter((f) => f.id !== filterId),
      });
    },
    [criteria.filters, setCriteria]
  );

  // Clear all filters
  const clearFilters = useCallback(() => {
    setCriteria({ filters: [] });
  }, [setCriteria]);

  // Mock search execution (replace with actual API call)
  const executeSearch = useCallback(async () => {
    setIsSearching(true);
    setError(null);

    try {
      // Simulate API delay
      await new Promise((resolve) => setTimeout(resolve, 500));

      // Mock search results
      const mockResults: SearchResponse = {
        results: generateMockResults(criteria),
        totalCount: 25,
        hasMore: true,
        facets: [
          {
            field: "status",
            label: "Status",
            values: [
              { value: "upcoming", label: "Upcoming", count: 12 },
              { value: "active", label: "Active", count: 8 },
              { value: "completed", label: "Completed", count: 5 },
            ],
          },
        ],
        suggestions: [
          "football tournament",
          "local matches",
          "beginner friendly",
        ],
        executionTime: 156,
        searchId: `search_${Date.now()}`,
      };

      setResults(mockResults);

      // Add to search history
      const historyEntry: SearchHistory = {
        id: `history_${Date.now()}`,
        query: criteria.query,
        category: criteria.category,
        userId: 1, // Get from auth context
        timestamp: new Date(),
        resultCount: mockResults.totalCount,
      };

      const newHistory = [historyEntry, ...searchHistory.slice(0, 49)]; // Keep last 50
      setSearchHistory(newHistory);
      saveToPersistence("lfa-search-history", newHistory);
    } catch (err) {
      setError("Search failed. Please try again.");
      console.error("Search error:", err);
    } finally {
      setIsSearching(false);
    }
  }, [criteria, searchHistory, saveToPersistence]);

  // Generate mock search results
  const generateMockResults = (criteria: SearchCriteria): SearchResult[] => {
    const baseResults: SearchResult[] = [
      {
        id: 1,
        type: "tournaments",
        title: "Friday Night Football Championship",
        subtitle: "NYC Football League",
        description: "Weekly competitive tournament for serious players",
        thumbnail: "/api/placeholder/100/100",
        url: "/tournaments/1",
        metadata: {
          status: "upcoming",
          entryFee: 25,
          participants: 12,
          maxParticipants: 16,
          startDate: new Date(Date.now() + 86400000),
        },
        relevanceScore: 0.95,
        highlights: ["Football", "Championship"],
      },
      {
        id: 2,
        type: "users",
        title: "Alex Rodriguez",
        subtitle: "Level 15 • 150 games played",
        description: "Experienced player looking for competitive matches",
        thumbnail: "/api/placeholder/60/60",
        url: "/users/2",
        metadata: {
          level: 15,
          gamesPlayed: 150,
          winRate: 0.68,
          joinDate: new Date("2023-01-15"),
        },
        relevanceScore: 0.82,
      },
      {
        id: 3,
        type: "locations",
        title: "Central Park Sports Complex",
        subtitle: "New York, NY",
        description:
          "Professional-grade football fields with modern facilities",
        thumbnail: "/api/placeholder/100/100",
        url: "/locations/3",
        metadata: {
          type: "complex",
          fields: 4,
          rating: 4.8,
          amenities: ["parking", "restrooms", "lighting"],
        },
        relevanceScore: 0.76,
      },
    ];

    // Filter based on category
    if (criteria.category !== "all") {
      return baseResults.filter((r) => r.type === criteria.category);
    }

    return baseResults;
  };

  // Clear search
  const clearSearch = useCallback(() => {
    setCriteriaState(defaultSearchCriteria);
    setResults(null);
    setError(null);
  }, []);

  // Save current search
  const saveCurrentSearch = useCallback(
    async (name: string) => {
      const savedSearch: SavedSearch = {
        id: `saved_${Date.now()}`,
        name,
        criteria: { ...criteria },
        userId: 1, // Get from auth context
        isBookmarked: false,
        createdAt: new Date(),
        lastUsed: new Date(),
        useCount: 1,
      };

      const newSavedSearches = [savedSearch, ...savedSearches];
      setSavedSearches(newSavedSearches);
      saveToPersistence("lfa-saved-searches", newSavedSearches);
    },
    [criteria, savedSearches, saveToPersistence]
  );

  // Load saved search
  const loadSavedSearch = useCallback(
    (searchId: string) => {
      const savedSearch = savedSearches.find((s) => s.id === searchId);
      if (savedSearch) {
        setCriteriaState(savedSearch.criteria);

        // Update last used
        const updatedSearches = savedSearches.map((s) =>
          s.id === searchId
            ? { ...s, lastUsed: new Date(), useCount: s.useCount + 1 }
            : s
        );
        setSavedSearches(updatedSearches);
        saveToPersistence("lfa-saved-searches", updatedSearches);
      }
    },
    [savedSearches, saveToPersistence]
  );

  // Delete saved search
  const deleteSavedSearch = useCallback(
    (searchId: string) => {
      const updatedSearches = savedSearches.filter((s) => s.id !== searchId);
      setSavedSearches(updatedSearches);
      saveToPersistence("lfa-saved-searches", updatedSearches);
    },
    [savedSearches, saveToPersistence]
  );

  // Clear search history
  const clearHistory = useCallback(() => {
    setSearchHistory([]);
    localStorage.removeItem("lfa-search-history");
  }, []);

  // Get suggestions (mock implementation)
  const getSuggestions = useCallback(
    async (query: string): Promise<SearchSuggestion[]> => {
      if (!query || query.length < 2) return [];

      // Simulate API delay
      await new Promise((resolve) => setTimeout(resolve, 200));

      const mockSuggestions: SearchSuggestion[] = [
        { text: "football tournament", type: "query" as const, popularity: 95 },
        { text: "soccer championship", type: "query" as const, popularity: 87 },
        { text: "local matches", type: "query" as const, popularity: 76 },
        {
          text: "beginner friendly",
          type: "filter" as const,
          category: "tournaments" as SearchCategory,
          popularity: 65,
        },
        {
          text: "tournaments",
          type: "category" as const,
          category: "tournaments" as SearchCategory,
          popularity: 90,
        },
      ].filter((s) => s.text.toLowerCase().includes(query.toLowerCase()));

      setSuggestions(mockSuggestions);
      return mockSuggestions;
    },
    []
  );

  // Apply filter builder
  const applyFilterBuilder = useCallback(() => {
    if (!filterBuilder) return;

    // Convert filter builder to search filters
    const convertGroupToFilters = (group: FilterBuilderGroup): any[] => {
      const filters: any[] = [];

      group.rules.forEach((rule) => {
        if ("field" in rule) {
          filters.push({
            id: rule.id,
            type: rule.type,
            field: rule.field,
            operator: rule.operator,
            value: rule.value,
            label: `${rule.field} ${rule.operator} ${rule.value}`,
          });
        } else {
          filters.push(...convertGroupToFilters(rule));
        }
      });

      return filters;
    };

    const newFilters = convertGroupToFilters(filterBuilder);
    setCriteria({ filters: newFilters });
  }, [filterBuilder, setCriteria]);

  const contextValue: SearchContextType = {
    // State
    criteria,
    results,
    isSearching,
    error,

    // Actions
    setCriteria,
    updateQuery,
    updateCategory,
    addFilter,
    removeFilter,
    clearFilters,
    executeSearch,
    clearSearch,

    // Saved searches
    savedSearches,
    saveCurrentSearch,
    loadSavedSearch,
    deleteSavedSearch,

    // History
    searchHistory,
    clearHistory,

    // Suggestions
    suggestions,
    getSuggestions,

    // Filter builder
    filterBuilder,
    setFilterBuilder,
    applyFilterBuilder,

    // Schema
    filterSchema,
  };

  return (
    <SearchContext.Provider value={contextValue}>
      {children}
    </SearchContext.Provider>
  );
};

// Hook to use search context
export const useSearch = (): SearchContextType => {
  const context = useContext(SearchContext);
  if (!context) {
    throw new Error("useSearch must be used within a SearchProvider");
  }
  return context;
};

export default SearchContext;


==== React Context: ThemeContext.tsx ==== (frontend/src/contexts/ThemeContext.tsx)
// src/contexts/ThemeContext.tsx
// TELJES JAVÍTOTT FÁJL - Material-UI Theme Context

import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
  ReactNode,
} from "react";
import {
  createTheme,
  ThemeProvider as MuiThemeProvider,
  Theme,
  alpha,
} from "@mui/material/styles";
import { PaletteMode } from "@mui/material";
import { CssBaseline } from "@mui/material";

// Theme configuration types
export interface ThemeConfig {
  mode: PaletteMode;
  colorScheme: ColorScheme;
  accentColor: AccentColor;
  contrastLevel: ContrastLevel;
  reducedMotion: boolean;
  fontSize: FontSize;
  borderRadius: BorderRadius;
  autoSchedule: boolean;
  scheduleSettings: ScheduleSettings;
  systemTheme: boolean;
}

export type ColorScheme =
  | "blue"
  | "green"
  | "purple"
  | "orange"
  | "red"
  | "teal"
  | "pink";
export type AccentColor =
  | "primary"
  | "secondary"
  | "success"
  | "warning"
  | "error"
  | "info";
export type ContrastLevel = "low" | "normal" | "high";
export type FontSize = "small" | "medium" | "large";
export type BorderRadius = "sharp" | "normal" | "rounded";

export interface ScheduleSettings {
  darkStart: string;
  darkEnd: string;
  useLocation: boolean;
  latitude?: number;
  longitude?: number;
}

// Theme context type
export interface ThemeContextType {
  config: ThemeConfig;
  theme: Theme;
  toggleTheme: () => void;
  setThemeMode: (mode: PaletteMode) => void;
  setColorScheme: (scheme: ColorScheme) => void;
  setAccentColor: (color: AccentColor) => void;
  setContrastLevel: (level: ContrastLevel) => void;
  setFontSize: (size: FontSize) => void;
  setBorderRadius: (radius: BorderRadius) => void;
  setReducedMotion: (reduced: boolean) => void;
  setAutoSchedule: (enabled: boolean) => void;
  setScheduleSettings: (settings: Partial<ScheduleSettings>) => void;
  setSystemTheme: (enabled: boolean) => void;
  resetToDefaults: () => void;
  exportConfig: () => string;
  importConfig: (config: string) => boolean;
}

// Default theme configuration
const defaultConfig: ThemeConfig = {
  mode: "light",
  colorScheme: "blue",
  accentColor: "primary",
  contrastLevel: "normal",
  reducedMotion: false,
  fontSize: "medium",
  borderRadius: "normal",
  autoSchedule: false,
  scheduleSettings: {
    darkStart: "20:00",
    darkEnd: "06:00",
    useLocation: false,
  },
  systemTheme: true,
};

// Storage key
const THEME_STORAGE_KEY = "lfa-theme-config";

// Color scheme definitions
const colorSchemes: Record<
  ColorScheme,
  { primary: string; secondary: string }
> = {
  blue: { primary: "#1976d2", secondary: "#dc004e" },
  green: { primary: "#2e7d32", secondary: "#ed6c02" },
  purple: { primary: "#7b1fa2", secondary: "#d32f2f" },
  orange: { primary: "#ed6c02", secondary: "#1976d2" },
  red: { primary: "#d32f2f", secondary: "#2e7d32" },
  teal: { primary: "#00695c", secondary: "#7b1fa2" },
  pink: { primary: "#c2185b", secondary: "#00695c" },
};

// Contrast level adjustments
const contrastAdjustments: Record<
  ContrastLevel,
  { factor: number; textContrast: number }
> = {
  low: { factor: 0.8, textContrast: 0.87 },
  normal: { factor: 1, textContrast: 0.87 },
  high: { factor: 1.3, textContrast: 1 },
};

// Font size scales
const fontSizeScales: Record<FontSize, number> = {
  small: 0.875,
  medium: 1,
  large: 1.125,
};

// Border radius scales
const borderRadiusScales: Record<BorderRadius, number> = {
  sharp: 0,
  normal: 1,
  rounded: 2,
};

// ✅ FIXED: Helper functions defined before createMaterialTheme
const getSystemTheme = (): PaletteMode => {
  if (typeof window === "undefined") return "light";
  return window.matchMedia("(prefers-color-scheme: dark)").matches
    ? "dark"
    : "light";
};

const getScheduledTheme = (settings: ScheduleSettings): PaletteMode => {
  const now = new Date();
  const currentTime = now.getHours() * 60 + now.getMinutes();

  const [darkStartHour, darkStartMin] = settings.darkStart
    .split(":")
    .map(Number);
  const [darkEndHour, darkEndMin] = settings.darkEnd.split(":").map(Number);

  const darkStart = darkStartHour * 60 + darkStartMin;
  const darkEnd = darkEndHour * 60 + darkEndMin;

  if (darkStart > darkEnd) {
    return currentTime >= darkStart || currentTime <= darkEnd
      ? "dark"
      : "light";
  } else {
    return currentTime >= darkStart && currentTime <= darkEnd
      ? "dark"
      : "light";
  }
};

const determineThemeMode = (config: ThemeConfig): PaletteMode => {
  if (config.systemTheme) {
    return getSystemTheme();
  } else if (config.autoSchedule) {
    return getScheduledTheme(config.scheduleSettings);
  }
  return config.mode;
};

// ✅ FIXED: createMaterialTheme function - properly defined before use
const createMaterialTheme = (config: ThemeConfig): Theme => {
  const actualMode = determineThemeMode(config);
  const colorScheme = colorSchemes[config.colorScheme];
  const contrast = contrastAdjustments[config.contrastLevel];
  const fontScale = fontSizeScales[config.fontSize];
  const radiusScale = borderRadiusScales[config.borderRadius];

  return createTheme({
    palette: {
      mode: actualMode,
      primary: {
        main: colorScheme.primary,
        ...(actualMode === "dark" && {
          main: alpha(colorScheme.primary, 0.9),
        }),
      },
      secondary: {
        main: colorScheme.secondary,
        ...(actualMode === "dark" && {
          main: alpha(colorScheme.secondary, 0.9),
        }),
      },
      ...(actualMode === "dark" && {
        background: {
          default: config.contrastLevel === "high" ? "#000000" : "#0a0a0a",
          paper: config.contrastLevel === "high" ? "#1a1a1a" : "#1e1e1e",
        },
        text: {
          primary: alpha("#ffffff", contrast.textContrast),
          secondary: alpha("#ffffff", 0.7 * contrast.textContrast),
        },
      }),
      ...(actualMode === "light" &&
        config.contrastLevel === "high" && {
          background: {
            default: "#ffffff",
            paper: "#f8f9fa",
          },
          text: {
            primary: "#000000",
            secondary: alpha("#000000", 0.8),
          },
        }),
    },
    typography: {
      fontSize: 14 * fontScale,
      fontFamily: '"Inter", "Roboto", "Helvetica", "Arial", sans-serif',
      h1: { fontSize: `${2.5 * fontScale}rem`, fontWeight: 600 },
      h2: { fontSize: `${2 * fontScale}rem`, fontWeight: 600 },
      h3: { fontSize: `${1.75 * fontScale}rem`, fontWeight: 600 },
      h4: { fontSize: `${1.5 * fontScale}rem`, fontWeight: 600 },
      h5: { fontSize: `${1.25 * fontScale}rem`, fontWeight: 600 },
      h6: { fontSize: `${1.1 * fontScale}rem`, fontWeight: 600 },
      body1: { fontSize: `${1 * fontScale}rem`, lineHeight: 1.6 },
      body2: { fontSize: `${0.875 * fontScale}rem`, lineHeight: 1.5 },
      button: { fontSize: `${0.875 * fontScale}rem`, fontWeight: 500 },
    },
    shape: {
      borderRadius: 8 * radiusScale,
    },
    transitions: {
      duration: {
        shortest: config.reducedMotion ? 0 : 150,
        shorter: config.reducedMotion ? 0 : 200,
        short: config.reducedMotion ? 0 : 250,
        standard: config.reducedMotion ? 0 : 300,
        complex: config.reducedMotion ? 0 : 375,
        enteringScreen: config.reducedMotion ? 0 : 225,
        leavingScreen: config.reducedMotion ? 0 : 195,
      },
    },
    components: {
      MuiButton: {
        styleOverrides: {
          root: {
            borderRadius: 8 * radiusScale,
            textTransform: "none",
            fontWeight: 500,
            transition: config.reducedMotion ? "none" : "all 0.2s ease-in-out",
          },
        },
      },
      MuiCard: {
        styleOverrides: {
          root: {
            borderRadius: 12 * radiusScale,
            transition: config.reducedMotion ? "none" : "all 0.3s ease-in-out",
          },
        },
      },
      MuiChip: {
        styleOverrides: {
          root: {
            borderRadius: 16 * radiusScale,
          },
        },
      },
      MuiTextField: {
        styleOverrides: {
          root: {
            "& .MuiOutlinedInput-root": {
              borderRadius: 8 * radiusScale,
              transition: config.reducedMotion
                ? "none"
                : "all 0.2s ease-in-out",
            },
          },
        },
      },
    },
  });
};

// Create theme context
const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// Theme provider component
interface ThemeProviderProps {
  children: ReactNode;
}

export const ThemeProvider: React.FC<ThemeProviderProps> = ({ children }) => {
  const [config, setConfig] = useState<ThemeConfig>(defaultConfig);
  const [theme, setTheme] = useState<Theme>(() =>
    createMaterialTheme(defaultConfig)
  );

  // Load theme configuration from localStorage
  const loadConfig = useCallback((): ThemeConfig => {
    try {
      const stored = localStorage.getItem(THEME_STORAGE_KEY);
      if (stored) {
        const parsedConfig = JSON.parse(stored);
        return { ...defaultConfig, ...parsedConfig };
      }
    } catch (error) {
      console.error("Failed to load theme config:", error);
    }
    return defaultConfig;
  }, []);

  // Save theme configuration to localStorage
  const saveConfig = useCallback((newConfig: ThemeConfig) => {
    try {
      localStorage.setItem(THEME_STORAGE_KEY, JSON.stringify(newConfig));
    } catch (error) {
      console.error("Failed to save theme config:", error);
    }
  }, []);

  // Update theme when config changes
  const updateTheme = useCallback(
    (newConfig: ThemeConfig) => {
      const newTheme = createMaterialTheme(newConfig);
      setConfig(newConfig);
      setTheme(newTheme);
      saveConfig(newConfig);
    },
    [saveConfig]
  );

  // Theme context actions
  const toggleTheme = useCallback(() => {
    const newMode: PaletteMode = config.mode === "light" ? "dark" : "light";
    updateTheme({ ...config, mode: newMode, systemTheme: false });
  }, [config, updateTheme]);

  const setThemeMode = useCallback(
    (mode: PaletteMode) => {
      updateTheme({ ...config, mode, systemTheme: false });
    },
    [config, updateTheme]
  );

  const setColorScheme = useCallback(
    (colorScheme: ColorScheme) => {
      updateTheme({ ...config, colorScheme });
    },
    [config, updateTheme]
  );

  const setAccentColor = useCallback(
    (accentColor: AccentColor) => {
      updateTheme({ ...config, accentColor });
    },
    [config, updateTheme]
  );

  const setContrastLevel = useCallback(
    (contrastLevel: ContrastLevel) => {
      updateTheme({ ...config, contrastLevel });
    },
    [config, updateTheme]
  );

  const setFontSize = useCallback(
    (fontSize: FontSize) => {
      updateTheme({ ...config, fontSize });
    },
    [config, updateTheme]
  );

  const setBorderRadius = useCallback(
    (borderRadius: BorderRadius) => {
      updateTheme({ ...config, borderRadius });
    },
    [config, updateTheme]
  );

  const setReducedMotion = useCallback(
    (reducedMotion: boolean) => {
      updateTheme({ ...config, reducedMotion });
    },
    [config, updateTheme]
  );

  const setAutoSchedule = useCallback(
    (autoSchedule: boolean) => {
      updateTheme({ ...config, autoSchedule });
    },
    [config, updateTheme]
  );

  const setScheduleSettings = useCallback(
    (scheduleSettings: Partial<ScheduleSettings>) => {
      updateTheme({
        ...config,
        scheduleSettings: { ...config.scheduleSettings, ...scheduleSettings },
      });
    },
    [config, updateTheme]
  );

  const setSystemTheme = useCallback(
    (systemTheme: boolean) => {
      updateTheme({ ...config, systemTheme });
    },
    [config, updateTheme]
  );

  const resetToDefaults = useCallback(() => {
    updateTheme(defaultConfig);
  }, [updateTheme]);

  const exportConfig = useCallback((): string => {
    return JSON.stringify(config, null, 2);
  }, [config]);

  const importConfig = useCallback(
    (configString: string): boolean => {
      try {
        const importedConfig = JSON.parse(configString);
        const validatedConfig = { ...defaultConfig, ...importedConfig };
        updateTheme(validatedConfig);
        return true;
      } catch (error) {
        console.error("Failed to import config:", error);
        return false;
      }
    },
    [updateTheme]
  );

  // Initialize theme on mount
  useEffect(() => {
    const loadedConfig = loadConfig();
    updateTheme(loadedConfig);
  }, [loadConfig, updateTheme]);

  // Listen for system theme changes
  useEffect(() => {
    if (!config.systemTheme) return;

    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    const handleChange = () => {
      if (config.systemTheme) {
        updateTheme({ ...config });
      }
    };

    mediaQuery.addEventListener("change", handleChange);
    return () => mediaQuery.removeEventListener("change", handleChange);
  }, [config, updateTheme]);

  const contextValue: ThemeContextType = {
    config,
    theme,
    toggleTheme,
    setThemeMode,
    setColorScheme,
    setAccentColor,
    setContrastLevel,
    setFontSize,
    setBorderRadius,
    setReducedMotion,
    setAutoSchedule,
    setScheduleSettings,
    setSystemTheme,
    resetToDefaults,
    exportConfig,
    importConfig,
  };

  return (
    <ThemeContext.Provider value={contextValue}>
      <MuiThemeProvider theme={theme}>
        <CssBaseline />
        {children}
      </MuiThemeProvider>
    </ThemeContext.Provider>
  );
};

// Hook to use theme context
export const useAppTheme = (): ThemeContextType => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error("useAppTheme must be used within a ThemeProvider");
  }
  return context;
};

export default ThemeContext;


==== Auth Component ==== (frontend/src/components/auth/AuthForm.tsx)
// src/components/auth/AuthForm.tsx
// LFA Legacy GO - Modern Authentication Forms

import React, { useState } from "react";
import {
  Box,
  Card,
  CardContent,
  TextField,
  Button,
  Typography,
  Tabs,
  Tab,
  Alert,
  IconButton,
  InputAdornment,
  Fade,
  CircularProgress,
  Divider,
  Link,
} from "@mui/material";
import {
  Visibility,
  VisibilityOff,
  SportsSoccer,
  Email,
  Person,
  Lock,
  Login as LoginIcon,
  PersonAdd,
} from "@mui/icons-material";
import { useSafeAuth } from "../../SafeAuthContext";

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

const TabPanel: React.FC<TabPanelProps> = ({ children, value, index }) => {
  return (
    <div hidden={value !== index}>
      {value === index && <Box sx={{ pt: 3 }}>{children}</Box>}
    </div>
  );
};

const AuthForm: React.FC = () => {
  const { state, login, register, clearError } = useSafeAuth();
  const [formData, setFormData] = useState({
    username: '',
    password: '',
    email: '',
    full_name: '',
    confirmPassword: ''
  });

  const isLoading = state.loading;
  const error = state.error;

  const handleInputChange = (field: string, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  const handleLogin = async () => {
    return await login({ username: formData.username, password: formData.password });
  };

  const handleRegister = async () => {
    return await register({
      username: formData.username,
      password: formData.password,
      email: formData.email,
      full_name: formData.full_name
    });
  };

  const resetForm = () => {
    setFormData({
      username: '',
      password: '',
      email: '',
      full_name: '',
      confirmPassword: ''
    });
  };

  const [activeTab, setActiveTab] = useState(0);
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [validationErrors, setValidationErrors] = useState<
    Record<string, string>
  >({});

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setActiveTab(newValue);
    resetForm();
    setValidationErrors({});
  };

  const validateForm = () => {
    const errors: Record<string, string> = {};

    if (!formData.username.trim()) {
      errors.username = "Username is required";
    } else if (formData.username.length < 3) {
      errors.username = "Username must be at least 3 characters";
    }

    if (!formData.password.trim()) {
      errors.password = "Password is required";
    } else if (formData.password.length < 6) {
      errors.password = "Password must be at least 6 characters";
    }

    // Registration-specific validation
    if (activeTab === 1) {
      if (!formData.full_name.trim()) {
        errors.full_name = "Full name is required";
      }

      if (!formData.email.trim()) {
        errors.email = "Email is required";
      } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
        errors.email = "Please enter a valid email address";
      }

      if (!formData.confirmPassword.trim()) {
        errors.confirmPassword = "Please confirm your password";
      } else if (formData.password !== formData.confirmPassword) {
        errors.confirmPassword = "Passwords do not match";
      }
    }

    setValidationErrors(errors);
    return Object.keys(errors).length === 0;
  };

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();

    if (!validateForm()) {
      return;
    }

    let success = false;
    if (activeTab === 0) {
      success = await handleLogin();
    } else {
      success = await handleRegister();
    }

    if (success) {
      // ✅ SUCCESS: AuthContext will handle redirect automatically
      // ProtectedRoute/PublicRoute components will redirect based on auth state
      // No manual navigation needed to prevent infinite loops
    }
  };

  const handleInputChangeWrapper =
    (field: string) => (event: React.ChangeEvent<HTMLInputElement>) => {
      handleInputChange(field, event.target.value);

      // Clear validation error for this field
      if (validationErrors[field]) {
        setValidationErrors((prev) => ({
          ...prev,
          [field]: "",
        }));
      }
    };

  return (
    <Box
      sx={{
        minHeight: "100vh",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        background:
          "linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%)",
        p: 2,
      }}
    >
      <Card
        sx={{
          maxWidth: 450,
          width: "100%",
          borderRadius: 3,
          boxShadow: "0 20px 40px rgba(0, 0, 0, 0.3)",
          background: "linear-gradient(145deg, #1e293b, #334155)",
          border: "1px solid rgba(71, 85, 105, 0.3)",
        }}
      >
        <CardContent sx={{ p: 4 }}>
          {/* Header */}
          <Box sx={{ textAlign: "center", mb: 3 }}>
            <Box
              sx={{
                display: "inline-flex",
                alignItems: "center",
                justifyContent: "center",
                width: 64,
                height: 64,
                borderRadius: "50%",
                background: "linear-gradient(135deg, #10b981, #059669)",
                mb: 2,
              }}
            >
              <SportsSoccer sx={{ fontSize: 32, color: "white" }} />
            </Box>
            <Typography
              variant="h4"
              sx={{
                fontWeight: 700,
                background: "linear-gradient(135deg, #10b981, #3b82f6)",
                backgroundClip: "text",
                WebkitBackgroundClip: "text",
                WebkitTextFillColor: "transparent",
                mb: 1,
              }}
            >
              LFA Legacy GO
            </Typography>
            <Typography variant="body2" color="text.secondary">
              Your Football Gaming Platform
            </Typography>
          </Box>

          {/* Error Alert */}
          {error && (
            <Fade in={Boolean(error)}>
              <Alert
                severity="error"
                onClose={clearError}
                sx={{ mb: 3, borderRadius: 2 }}
              >
                {error}
              </Alert>
            </Fade>
          )}

          {/* Tabs */}
          <Tabs
            value={activeTab}
            onChange={handleTabChange}
            variant="fullWidth"
            sx={{
              mb: 2,
              "& .MuiTab-root": {
                textTransform: "none",
                fontWeight: 500,
                fontSize: "1rem",
              },
            }}
          >
            <Tab
              icon={<LoginIcon />}
              iconPosition="start"
              label="Login"
              disabled={isLoading}
            />
            <Tab
              icon={<PersonAdd />}
              iconPosition="start"
              label="Register"
              disabled={isLoading}
            />
          </Tabs>

          {/* Forms */}
          <form onSubmit={handleSubmit}>
            {/* Login Form */}
            <TabPanel value={activeTab} index={0}>
              <Box sx={{ display: "flex", flexDirection: "column", gap: 2.5 }}>
                <TextField
                  label="Username"
                  value={formData.username}
                  onChange={handleInputChangeWrapper("username")}
                  error={Boolean(validationErrors.username)}
                  helperText={validationErrors.username}
                  disabled={isLoading}
                  fullWidth
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <Person color="action" />
                      </InputAdornment>
                    ),
                  }}
                />

                <TextField
                  label="Password"
                  type={showPassword ? "text" : "password"}
                  value={formData.password}
                  onChange={handleInputChangeWrapper("password")}
                  error={Boolean(validationErrors.password)}
                  helperText={validationErrors.password}
                  disabled={isLoading}
                  fullWidth
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <Lock color="action" />
                      </InputAdornment>
                    ),
                    endAdornment: (
                      <InputAdornment position="end">
                        <IconButton
                          onClick={() => setShowPassword(!showPassword)}
                          disabled={isLoading}
                          edge="end"
                        >
                          {showPassword ? <VisibilityOff /> : <Visibility />}
                        </IconButton>
                      </InputAdornment>
                    ),
                  }}
                />
              </Box>
            </TabPanel>

            {/* Register Form */}
            <TabPanel value={activeTab} index={1}>
              <Box sx={{ display: "flex", flexDirection: "column", gap: 2.5 }}>
                <TextField
                  label="Full Name"
                  value={formData.full_name}
                  onChange={handleInputChangeWrapper("full_name")}
                  error={Boolean(validationErrors.full_name)}
                  helperText={validationErrors.full_name}
                  disabled={isLoading}
                  fullWidth
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <Person color="action" />
                      </InputAdornment>
                    ),
                  }}
                />

                <TextField
                  label="Username"
                  value={formData.username}
                  onChange={handleInputChangeWrapper("username")}
                  error={Boolean(validationErrors.username)}
                  helperText={validationErrors.username}
                  disabled={isLoading}
                  fullWidth
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <Person color="action" />
                      </InputAdornment>
                    ),
                  }}
                />

                <TextField
                  label="Email"
                  type="email"
                  value={formData.email}
                  onChange={handleInputChangeWrapper("email")}
                  error={Boolean(validationErrors.email)}
                  helperText={validationErrors.email}
                  disabled={isLoading}
                  fullWidth
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <Email color="action" />
                      </InputAdornment>
                    ),
                  }}
                />

                <TextField
                  label="Password"
                  type={showPassword ? "text" : "password"}
                  value={formData.password}
                  onChange={handleInputChangeWrapper("password")}
                  error={Boolean(validationErrors.password)}
                  helperText={validationErrors.password}
                  disabled={isLoading}
                  fullWidth
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <Lock color="action" />
                      </InputAdornment>
                    ),
                    endAdornment: (
                      <InputAdornment position="end">
                        <IconButton
                          onClick={() => setShowPassword(!showPassword)}
                          disabled={isLoading}
                          edge="end"
                        >
                          {showPassword ? <VisibilityOff /> : <Visibility />}
                        </IconButton>
                      </InputAdornment>
                    ),
                  }}
                />

                <TextField
                  label="Confirm Password"
                  type={showConfirmPassword ? "text" : "password"}
                  value={formData.confirmPassword}
                  onChange={handleInputChangeWrapper("confirmPassword")}
                  error={Boolean(validationErrors.confirmPassword)}
                  helperText={validationErrors.confirmPassword}
                  disabled={isLoading}
                  fullWidth
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <Lock color="action" />
                      </InputAdornment>
                    ),
                    endAdornment: (
                      <InputAdornment position="end">
                        <IconButton
                          onClick={() =>
                            setShowConfirmPassword(!showConfirmPassword)
                          }
                          disabled={isLoading}
                          edge="end"
                        >
                          {showConfirmPassword ? (
                            <VisibilityOff />
                          ) : (
                            <Visibility />
                          )}
                        </IconButton>
                      </InputAdornment>
                    ),
                  }}
                />
              </Box>
            </TabPanel>

            {/* Submit Button */}
            <Button
              type="submit"
              variant="contained"
              size="large"
              fullWidth
              disabled={isLoading}
              sx={{
                mt: 3,
                py: 1.5,
                fontSize: "1.1rem",
                fontWeight: 600,
                background: "linear-gradient(135deg, #10b981, #059669)",
                "&:hover": {
                  background: "linear-gradient(135deg, #059669, #047857)",
                  transform: "translateY(-1px)",
                },
                "&:disabled": {
                  background: "rgba(16, 185, 129, 0.3)",
                },
              }}
              startIcon={
                isLoading ? (
                  <CircularProgress size={20} color="inherit" />
                ) : activeTab === 0 ? (
                  <LoginIcon />
                ) : (
                  <PersonAdd />
                )
              }
            >
              {isLoading
                ? activeTab === 0
                  ? "Signing In..."
                  : "Creating Account..."
                : activeTab === 0
                  ? "Sign In"
                  : "Create Account"}
            </Button>
          </form>

          {/* Footer */}
          <Divider sx={{ my: 3 }} />
          <Box sx={{ textAlign: "center" }}>
            <Typography variant="body2" color="text.secondary">
              {activeTab === 0
                ? "Don't have an account? "
                : "Already have an account? "}
              <Link
                component="button"
                type="button"
                onClick={() =>
                  handleTabChange(
                    {} as React.SyntheticEvent,
                    activeTab === 0 ? 1 : 0
                  )
                }
                disabled={isLoading}
                sx={{
                  color: "primary.main",
                  textDecoration: "none",
                  fontWeight: 500,
                  "&:hover": {
                    textDecoration: "underline",
                  },
                }}
              >
                {activeTab === 0 ? "Sign Up" : "Sign In"}
              </Link>
            </Typography>
          </Box>
        </CardContent>
      </Card>
    </Box>
  );
};

export default AuthForm;


==== Dashboard Component ==== (frontend/src/components/dashboard/Dashboard.tsx)
// src/components/dashboard/Dashboard.tsx
// LFA Legacy GO - Dashboard with REAL API data (no mock)

import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import {
  Box,
  Typography,
  Card,
  CardContent,
  Grid,
  Button,
  Chip,
  LinearProgress,
  Avatar,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  IconButton,
  Paper,
  Divider,
  Alert,
  CircularProgress,
  Fab,
  Fade,
} from "@mui/material";
import {
  AccountBalanceWallet,
  EmojiEvents,
  People,
  CalendarMonth,
  SportsScore,
  TrendingUp,
  Star,
  ArrowForward,
  Refresh,
  Add,
  Assessment,
} from "@mui/icons-material";
import { useSafeAuth } from "../../SafeAuthContext";
import { gameResultsService } from "../../services/gameResultsService";

interface QuickAction {
  title: string;
  description: string;
  icon: React.ReactNode;
  color: string;
  action: () => void;
}

interface RecentActivity {
  id: number;
  type: "game" | "booking" | "tournament" | "achievement";
  title: string;
  description: string;
  timestamp: string;
  icon: React.ReactNode;
  color: string;
}

interface GameStats {
  games_played: number;
  games_won: number;
  games_lost: number;
  games_drawn: number;
  win_rate: number;
  total_playtime: number;
  recent_results: any[];
}

const Dashboard: React.FC = () => {
  const navigate = useNavigate();
  const { state, refreshStats } = useSafeAuth();
  const { user } = state;

  const [loading, setLoading] = useState(false);
  const [gameStats, setGameStats] = useState<GameStats | null>(null);
  const [statsLoading, setStatsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Load game statistics on component mount
  useEffect(() => {
    loadGameStatistics();
  }, []);

  const loadGameStatistics = async () => {
    try {
      setStatsLoading(true);
      setError(null);

      // ✅ REAL API CALL - no mock logic
      const stats = await gameResultsService.getStatistics("all");

      setGameStats({
        games_played: stats.overall.games_played,
        games_won: stats.overall.games_won,
        games_lost: stats.overall.games_lost,
        games_drawn: stats.overall.games_drawn,
        win_rate: stats.overall.win_rate,
        total_playtime: stats.overall.total_playtime,
        recent_results: stats.recent_performance?.last_5_games || [],
      });
    } catch (err: any) {
      console.error("Failed to load game statistics:", err);

      // ✅ REAL FALLBACK - use user data from auth, NOT mock data
      const fallbackStats = {
        games_played: user?.games_played || 0,
        games_won: user?.games_won || 0,
        games_lost: user?.games_lost || 0,
        games_drawn: 0,
        win_rate:
          user?.games_played && user?.games_won
            ? Math.round(
                ((user.games_won || 0) / Math.max(user.games_played || 1, 1)) *
                  100
              )
            : 0,
        total_playtime: 0,
        recent_results: [],
      };

      setGameStats(fallbackStats);

      // Show a helpful error message
      if (err.response?.status === 404) {
        setError("Game statistics not found. Start playing to see your stats!");
      } else if (err.response?.status >= 500) {
        setError("Server error loading statistics. Using cached data.");
      } else {
        setError(
          "Unable to load latest statistics. Some data may be outdated."
        );
      }
    } finally {
      setStatsLoading(false);
    }
  };

  const handleRefresh = async () => {
    setLoading(true);
    try {
      await Promise.all([
        loadGameStatistics(),
        refreshStats ? refreshStats() : Promise.resolve(),
      ]);
      setError(null); // Clear any previous errors on successful refresh
    } catch (err) {
      console.error("Refresh failed:", err);
      setError("Failed to refresh data. Please try again.");
    } finally {
      setLoading(false);
    }
  };

  // ✅ Calculate user progress with proper XP handling
  const currentXP = user?.xp || 0;
  const currentLevel = user?.level || 1;
  const xpForNextLevel = currentLevel * 100; // XP required for next level
  const progressPercent = Math.min((currentXP / xpForNextLevel) * 100, 100);

  // ✅ Use REAL game statistics (no mock logic)
  const winRate = gameStats?.win_rate || 0;
  const gamesPlayed = gameStats?.games_played || 0;
  const gamesWon = gameStats?.games_won || 0;

  // Quick Action Cards
  const quickActions: QuickAction[] = [
    {
      title: "Join Tournament",
      description: "Find and join upcoming tournaments",
      icon: <EmojiEvents />,
      color: "primary",
      action: () => navigate("/tournaments"),
    },
    {
      title: "Add Game Result",
      description: "Record your latest game results",
      icon: <Add />,
      color: "success",
      action: () => navigate("/game-results?action=add"),
    },
    {
      title: "View Statistics",
      description: "Detailed performance analytics",
      icon: <Assessment />,
      color: "info",
      action: () => navigate("/game-results"),
    },
    {
      title: "Social Hub",
      description: "Connect with friends and challengers",
      icon: <People />,
      color: "secondary",
      action: () => navigate("/social"),
    },
  ];

  // Statistics cards with REAL data
  const statsCards = [
    {
      title: "Current Level",
      value: user?.level || 1,
      icon: <Star />,
      color: "primary",
      progress: progressPercent,
      subtitle: `${currentXP}/${xpForNextLevel} XP`,
      action: () => navigate("/profile"),
    },
    {
      title: "Credits",
      value: user?.credits || 0,
      icon: <AccountBalanceWallet />,
      color: "success",
      subtitle: "Available balance",
      action: () => navigate("/credits"),
    },
    {
      title: "Games Played",
      value: gamesPlayed,
      icon: <SportsScore />,
      color: "info",
      subtitle: statsLoading ? "Loading..." : `${gamesWon} wins`,
      winRate: winRate,
      action: () => navigate("/game-results"),
    },
    {
      title: "Win Rate",
      value: `${winRate.toFixed(1)}%`,
      icon: <TrendingUp />,
      color: "warning",
      subtitle: gamesPlayed > 0 ? `${gamesPlayed} total games` : "No games yet",
      action: () => navigate("/game-results"),
    },
  ];

  // Recent activities with real data integration
  const recentActivities: RecentActivity[] = [
    {
      id: 1,
      type: "game",
      title: "Last Game Result",
      description:
        gamesPlayed > 0
          ? `${winRate > 50 ? "Victory" : "Good effort"} in recent match`
          : "No games recorded yet",
      timestamp: "Recently",
      icon: <SportsScore />,
      color: winRate > 50 ? "success.main" : "info.main",
    },
    {
      id: 2,
      type: "tournament",
      title: "Tournament Activity",
      description: "Check upcoming tournaments",
      timestamp: "Today",
      icon: <EmojiEvents />,
      color: "primary.main",
    },
    {
      id: 3,
      type: "achievement",
      title: "Level Progress",
      description: `Level ${user?.level || 1} - ${progressPercent.toFixed(
        0
      )}% to next`,
      timestamp: "Current",
      icon: <Star />,
      color: "warning.main",
    },
  ];

  return (
    <Box>
      {/* Header */}
      <Box
        sx={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          flexDirection: { xs: "column", md: "row" },
          gap: 2,
          mb: 3,
        }}
      >
        <Typography variant="h4" component="h1" fontWeight="bold">
          Welcome back, {user?.full_name || user?.username}!
        </Typography>
        <Box sx={{ display: "flex", gap: 1 }}>
          <Button
            variant="outlined"
            startIcon={<Refresh />}
            onClick={handleRefresh}
            disabled={loading}
          >
            {loading ? "Refreshing..." : "Refresh"}
          </Button>
        </Box>
      </Box>

      {/* Error Alert */}
      {error && (
        <Alert
          severity={
            error.includes("cached") || error.includes("outdated")
              ? "warning"
              : "info"
          }
          sx={{ mb: 3 }}
          onClose={() => setError(null)}
        >
          {error}
        </Alert>
      )}

      {/* Statistics Cards */}
      <Grid container spacing={3}>
        {statsCards.map((stat, index) => (
          <Grid item xs={12} sm={6} md={3} key={stat.title}>
            <Fade in timeout={300 * (index + 1)}>
              <Card
                sx={{
                  height: "100%",
                  cursor: stat.action ? "pointer" : "default",
                  transition: "transform 0.2s, box-shadow 0.2s",
                  "&:hover": stat.action
                    ? {
                        transform: "translateY(-4px)",
                        boxShadow: 4,
                      }
                    : {},
                }}
                onClick={stat.action}
              >
                <CardContent>
                  <Box
                    sx={{
                      display: "flex",
                      alignItems: "center",
                      gap: 2,
                      mb: 2,
                    }}
                  >
                    <Box sx={{ color: `${stat.color}.main` }}>{stat.icon}</Box>
                    <Box sx={{ flexGrow: 1 }}>
                      <Typography
                        variant="h4"
                        component="div"
                        fontWeight="bold"
                      >
                        {statsLoading && stat.title.includes("Games") ? (
                          <CircularProgress size={24} />
                        ) : (
                          stat.value
                        )}
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        {stat.title}
                      </Typography>
                    </Box>
                    {stat.action && (
                      <IconButton size="small" color={stat.color as any}>
                        <ArrowForward />
                      </IconButton>
                    )}
                  </Box>

                  {stat.progress !== undefined && (
                    <Box>
                      <Typography variant="caption" color="text.secondary">
                        Progress to next level
                      </Typography>
                      <LinearProgress
                        variant="determinate"
                        value={stat.progress}
                        color={stat.color as any}
                        sx={{ mt: 1, height: 6, borderRadius: 3 }}
                      />
                    </Box>
                  )}

                  {stat.winRate !== undefined && (
                    <Box>
                      <Typography variant="caption" color="text.secondary">
                        Win Rate
                      </Typography>
                      <LinearProgress
                        variant="determinate"
                        value={stat.winRate}
                        color={stat.color as any}
                        sx={{ mt: 1, height: 6, borderRadius: 3 }}
                      />
                      <Typography
                        variant="caption"
                        sx={{ mt: 0.5, display: "block" }}
                      >
                        {stat.winRate.toFixed(1)}%
                      </Typography>
                    </Box>
                  )}

                  {stat.subtitle && (
                    <Typography
                      variant="caption"
                      color="text.secondary"
                      sx={{ mt: 1, display: "block" }}
                    >
                      {stat.subtitle}
                    </Typography>
                  )}
                </CardContent>
              </Card>
            </Fade>
          </Grid>
        ))}
      </Grid>

      {/* Quick Actions and Recent Activities */}
      <Grid container spacing={3} sx={{ mt: 2 }}>
        {/* Quick Actions */}
        <Grid item xs={12} md={6}>
          <Card>
            <CardContent>
              <Box
                sx={{ display: "flex", alignItems: "center", gap: 1, mb: 2 }}
              >
                <ArrowForward color="primary" />
                <Typography variant="h6">Quick Actions</Typography>
              </Box>
              <Grid container spacing={2}>
                {quickActions.map((action) => (
                  <Grid item xs={6} key={action.title}>
                    <Card
                      variant="outlined"
                      sx={{
                        cursor: "pointer",
                        transition: "all 0.2s",
                        "&:hover": {
                          backgroundColor: "action.hover",
                          transform: "scale(1.02)",
                        },
                      }}
                      onClick={action.action}
                    >
                      <CardContent sx={{ textAlign: "center", py: 2 }}>
                        <Box sx={{ color: `${action.color}.main`, mb: 1 }}>
                          {action.icon}
                        </Box>
                        <Typography variant="subtitle2" fontWeight="bold">
                          {action.title}
                        </Typography>
                        <Typography variant="caption" color="text.secondary">
                          {action.description}
                        </Typography>
                      </CardContent>
                    </Card>
                  </Grid>
                ))}
              </Grid>
            </CardContent>
          </Card>
        </Grid>

        {/* Recent Activities */}
        <Grid item xs={12} md={6}>
          <Card>
            <CardContent>
              <Box
                sx={{ display: "flex", alignItems: "center", gap: 1, mb: 2 }}
              >
                <CalendarMonth color="primary" />
                <Typography variant="h6">Recent Activity</Typography>
              </Box>
              <List disablePadding>
                {recentActivities.map((activity, index) => (
                  <ListItem
                    key={activity.id}
                    sx={{
                      borderRadius: 1,
                      "&:hover": { backgroundColor: "action.hover" },
                    }}
                  >
                    <ListItemIcon>
                      <Avatar
                        sx={{
                          bgcolor: activity.color,
                          width: 32,
                          height: 32,
                        }}
                      >
                        {activity.icon}
                      </Avatar>
                    </ListItemIcon>
                    <ListItemText
                      primary={activity.title}
                      secondary={
                        <Box>
                          <Typography variant="body2" color="text.secondary">
                            {activity.description}
                          </Typography>
                          <Typography variant="caption" color="text.disabled">
                            {activity.timestamp}
                          </Typography>
                        </Box>
                      }
                    />
                  </ListItem>
                ))}
              </List>
            </CardContent>
          </Card>
        </Grid>
      </Grid>

      {/* Floating Action Button */}
      <Fab
        color="primary"
        aria-label="add game result"
        sx={{
          position: "fixed",
          bottom: 16,
          right: 16,
        }}
        onClick={() => navigate("/game-results?action=add")}
      >
        <Add />
      </Fab>
    </Box>
  );
};

export default Dashboard;


==== Layout Component ==== (frontend/src/components/layout/Layout.tsx)
// src/components/layout/Layout.tsx
// LFA Legacy GO - Main Layout with Navigation

import React from "react";
import {
  AppBar,
  Toolbar,
  Typography,
  Button,
  Box,
  Container,
  Menu,
  MenuItem,
  IconButton,
  Chip,
  Drawer,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  useMediaQuery,
  useTheme,
} from "@mui/material";
import { useNavigate } from "react-router-dom";
import {
  SportsSoccer,
  Dashboard as DashboardIcon,
  EmojiEvents,
  Person,
  Logout,
  AccountCircle,
  Menu as MenuIcon,
  People,
  Assessment,
} from "@mui/icons-material";
import { useSafeAuth } from "../../SafeAuthContext";

interface LayoutProps {
  children: React.ReactNode;
}

const Layout: React.FC<LayoutProps> = ({ children }) => {
  const { state, logout } = useSafeAuth();
  const navigate = useNavigate();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("md"));

  const [anchorEl, setAnchorEl] = React.useState<null | HTMLElement>(null);
  const [mobileOpen, setMobileOpen] = React.useState(false);

  const handleMenu = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  const handleLogout = async () => {
    try {
      await logout();
      handleClose();
      navigate('/login');
    } catch (error) {
      console.error('Logout failed:', error);
      handleClose();
      navigate('/login');
    }
  };

  const handleMobileDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const navigationItems = [
    { label: "Dashboard", href: "/", icon: <DashboardIcon /> },
    { label: "Tournaments", href: "/tournaments", icon: <EmojiEvents /> },
    { label: "Social", href: "/social", icon: <People /> },
    { label: "Game Results", href: "/game-results", icon: <Assessment /> },
    { label: "Profile", href: "/profile", icon: <Person /> },
  ];

  const drawer = (
    <Box sx={{ width: 250 }}>
      <Box sx={{ p: 2, borderBottom: 1, borderColor: "divider" }}>
        <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
          <SportsSoccer color="primary" />
          <Typography variant="h6" fontWeight="bold">
            LFA Legacy GO
          </Typography>
        </Box>
      </Box>

      <List>
        {navigationItems.map((item) => (
          <ListItem
            key={item.label}
            onClick={() => {
              navigate(item.href);
              setMobileOpen(false);
            }}
            sx={{ cursor: "pointer" }}
          >
            <ListItemIcon>{item.icon}</ListItemIcon>
            <ListItemText primary={item.label} />
          </ListItem>
        ))}
      </List>
    </Box>
  );

  return (
    <Box sx={{ flexGrow: 1 }}>
      <AppBar
        position="static"
        sx={{ background: "linear-gradient(135deg, #10b981, #059669)" }}
      >
        <Toolbar>
          {isMobile && (
            <IconButton
              color="inherit"
              aria-label="open drawer"
              edge="start"
              onClick={handleMobileDrawerToggle}
              sx={{ mr: 2 }}
            >
              <MenuIcon />
            </IconButton>
          )}

          <SportsSoccer sx={{ mr: 2 }} />
          <Typography
            variant="h6"
            component="div"
            sx={{ flexGrow: 1, fontWeight: "bold" }}
          >
            LFA Legacy GO
          </Typography>

          {!isMobile && (
            <Box sx={{ display: "flex", gap: 2, alignItems: "center" }}>
              {navigationItems.map((item) => (
                <Button
                  key={item.label}
                  color="inherit"
                  startIcon={item.icon}
                  onClick={() => navigate(item.href)}
                  sx={{
                    "&:hover": {
                      backgroundColor: "rgba(255, 255, 255, 0.1)",
                    },
                  }}
                >
                  {item.label}
                </Button>
              ))}
            </Box>
          )}

          <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
            {state.user && (
              <Chip
                label={`${state.user.credits} Credits`}
                color="secondary"
                variant="outlined"
                size={isMobile ? "small" : "medium"}
                sx={{ color: "white", borderColor: "white" }}
              />
            )}

            <IconButton
              size="large"
              aria-label="account of current user"
              aria-controls="menu-appbar"
              aria-haspopup="true"
              onClick={handleMenu}
              color="inherit"
            >
              <AccountCircle />
            </IconButton>
            <Menu
              id="menu-appbar"
              anchorEl={anchorEl}
              anchorOrigin={{
                vertical: "top",
                horizontal: "right",
              }}
              keepMounted
              transformOrigin={{
                vertical: "top",
                horizontal: "right",
              }}
              open={Boolean(anchorEl)}
              onClose={handleClose}
            >
              <MenuItem
                onClick={() => {
                  navigate("/profile");
                  handleClose();
                }}
              >
                <Person sx={{ mr: 1 }} /> Profile
              </MenuItem>
              <MenuItem onClick={handleLogout}>
                <Logout sx={{ mr: 1 }} /> Logout
              </MenuItem>
            </Menu>
          </Box>
        </Toolbar>
      </AppBar>

      {/* Mobile Drawer */}
      <Drawer
        variant="temporary"
        open={mobileOpen}
        onClose={handleMobileDrawerToggle}
        ModalProps={{
          keepMounted: true, // Better open performance on mobile.
        }}
        sx={{
          display: { xs: "block", md: "none" },
          "& .MuiDrawer-paper": { boxSizing: "border-box", width: 250 },
        }}
      >
        {drawer}
      </Drawer>

      <Container
        maxWidth="lg"
        sx={{
          py: { xs: 2, sm: 3, md: 4 },
          px: { xs: 2, sm: 3, md: 4 },
        }}
      >
        {children}
      </Container>
    </Box>
  );
};

export default Layout;


==== Page Component: AdminPanel-backup.tsx ==== (frontend/src/pages/AdminPanel-backup.tsx)
import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import {
  Box,
  Typography,
  Card,
  CardContent,
  Grid,
  Button,
  IconButton,
  Alert,
  Tabs,
  Tab,
  Paper,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Chip,
  Avatar,
  LinearProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Divider,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  ListItemAvatar,
  CircularProgress,
  Badge,
} from "@mui/material";
import {
  ArrowBack,
  Dashboard,
  People,
  EmojiEvents,
  Settings,
  Security,
  Assessment,
  Warning,
  CheckCircle,
  Error,
  Info,
  Refresh,
  Edit,
  Delete,
  Block,
  PersonAdd,
  AdminPanelSettings,
  SupervisorAccount,
  NetworkCheck,
  Storage,
  Memory,
  Speed,
  TrendingUp,
  TrendingDown,
  MoreVert,
} from "@mui/icons-material";
import { useSafeAuth } from "../SafeAuthContext";

// Interfaces for Admin Panel
interface SystemMetrics {
  totalUsers: number;
  activeUsers: number;
  totalTournaments: number;
  activeTournaments: number;
  systemHealth: "healthy" | "warning" | "critical";
  memoryUsage: number;
  cpuUsage: number;
  diskUsage: number;
  apiResponseTime: number;
}

interface AdminUser {
  id: number;
  username: string;
  full_name: string;
  email: string;
  level: number;
  credits: number;
  is_active: boolean;
  is_admin: boolean;
  last_activity: string;
  registration_date: string;
  games_played: number;
  total_spent: number;
}

interface SystemAlert {
  id: string;
  type: "error" | "warning" | "info" | "success";
  title: string;
  message: string;
  timestamp: string;
  resolved: boolean;
}

const AdminPanel: React.FC = () => {
  console.log("ADMIN PANEL LOADED");
  const navigate = useNavigate();
  const { state } = useSafeAuth();
  const [activeTab, setActiveTab] = useState(0);
  const [loading, setLoading] = useState(true);
  const [metrics, setMetrics] = useState<SystemMetrics | null>(null);
  const [users, setUsers] = useState<AdminUser[]>([]);
  const [alerts, setAlerts] = useState<SystemAlert[]>([]);
  const [selectedUser, setSelectedUser] = useState<AdminUser | null>(null);
  const [userDialogOpen, setUserDialogOpen] = useState(false);
  const [refreshing, setRefreshing] = useState(false);

  // Check if user is admin (basic auth check)
  useEffect(() => {
    console.log("🔍 AdminPanel - FULL State:", state);
    console.log("🔍 AdminPanel - User object:", state.user);
    console.log("🔍 AdminPanel - user_type:", state.user?.user_type);
    console.log("🔍 AdminPanel - is_admin:", state.user?.is_admin);
    console.log("🔍 AdminPanel - isAuthenticated:", state.isAuthenticated);
    console.log("🔍 AdminPanel - loading:", state.loading);
    
    // Check admin status using user_type instead of is_admin
    const isAdmin = state.user?.user_type === "admin" || state.user?.user_type === "moderator" || state.user?.is_admin;
    console.log("🔍 AdminPanel - Computed isAdmin:", isAdmin);
    
    if (!state.user) {
      console.log("🚫 AdminPanel - No user object, waiting...");
      return;
    }
    
    if (!isAdmin) {
      console.log("🚫 AdminPanel - Access denied, redirecting to dashboard");
      console.log("🚫 AdminPanel - Redirect reason: user_type=", state.user?.user_type, "is_admin=", state.user?.is_admin);
      navigate("/dashboard");
      return;
    }
    
    console.log("✅ AdminPanel - Admin access granted, loading admin data");
    loadAdminData();
  }, [state.user, navigate]);

  const loadAdminData = async () => {
    try {
      setLoading(true);

      // Simulate loading admin data (replace with real API calls)
      await new Promise((resolve) => setTimeout(resolve, 1500));

      // Mock system metrics
      setMetrics({
        totalUsers: 1247,
        activeUsers: 89,
        totalTournaments: 156,
        activeTournaments: 12,
        systemHealth: "healthy",
        memoryUsage: 67,
        cpuUsage: 23,
        diskUsage: 45,
        apiResponseTime: 142,
      });

      // Mock user data
      setUsers([
        {
          id: 1,
          username: "striker23",
          full_name: "Alex Rodriguez",
          email: "alex@example.com",
          level: 7,
          credits: 150,
          is_active: true,
          is_admin: false,
          last_activity: "2025-08-17T17:30:00Z",
          registration_date: "2024-12-01",
          games_played: 34,
          total_spent: 89.99,
        },
        {
          id: 2,
          username: "goalkeeper",
          full_name: "Sarah Chen",
          email: "sarah@example.com",
          level: 6,
          credits: 75,
          is_active: true,
          is_admin: false,
          last_activity: "2025-08-17T16:45:00Z",
          registration_date: "2024-11-15",
          games_played: 28,
          total_spent: 45.5,
        },
      ]);

      // Mock system alerts
      setAlerts([
        {
          id: "1",
          type: "info",
          title: "System Update",
          message: "Backend successfully updated to version 3.1.0",
          timestamp: "2025-08-17T18:00:00Z",
          resolved: true,
        },
        {
          id: "2",
          type: "warning",
          title: "High Memory Usage",
          message: "Frontend memory usage above 2GB threshold",
          timestamp: "2025-08-17T17:45:00Z",
          resolved: false,
        },
      ]);
    } catch (error) {
      console.error("Failed to load admin data:", error);
    } finally {
      setLoading(false);
    }
  };

  const handleRefresh = async () => {
    setRefreshing(true);
    await loadAdminData();
    setRefreshing(false);
  };

  const handleUserAction = (action: string, userId: number) => {
    console.log(`Admin action: ${action} for user ${userId}`);
    // Implement user management actions
  };

  const formatLastActivity = (timestamp: string) => {
    const now = new Date();
    const activity = new Date(timestamp);
    const diffMs = now.getTime() - activity.getTime();
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));

    if (diffHours < 1) return "Active now";
    if (diffHours < 24) return `${diffHours}h ago`;
    return `${Math.floor(diffHours / 24)}d ago`;
  };

  const getHealthColor = (health: string) => {
    switch (health) {
      case "healthy":
        return "success";
      case "warning":
        return "warning";
      case "critical":
        return "error";
      default:
        return "default";
    }
  };

  // Check admin status using user_type instead of is_admin
  const isAdmin = state.user?.user_type === "admin" || state.user?.user_type === "moderator" || state.user?.is_admin;
  
  if (!isAdmin) {
    return (
      <Box sx={{ p: 3 }}>
        <Alert severity="error">
          Access Denied: Administrator privileges required.
          <br />
          Current user type: {state.user?.user_type || "unknown"}
        </Alert>
      </Box>
    );
  }

  if (loading) {
    return (
      <Box
        sx={{
          minHeight: "60vh",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          flexDirection: "column",
          gap: 2,
        }}
      >
        <CircularProgress size={60} />
        <Typography variant="h6" color="text.secondary">
          Loading Admin Dashboard...
        </Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ p: 3 }}>
      {/* Header */}
      <Box
        sx={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          mb: 4,
        }}
      >
        <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
          <IconButton onClick={() => navigate("/dashboard")}>
            <ArrowBack />
          </IconButton>
          <AdminPanelSettings sx={{ fontSize: 32, color: "primary.main" }} />
          <Box>
            <Typography variant="h4" fontWeight="bold">
              Admin Dashboard
            </Typography>
            <Typography variant="body2" color="text.secondary">
              System management and user oversight
            </Typography>
          </Box>
        </Box>

        <Box sx={{ display: "flex", gap: 1 }}>
          <Button
            variant="outlined"
            startIcon={<Refresh />}
            onClick={handleRefresh}
            disabled={refreshing}
          >
            {refreshing ? "Refreshing..." : "Refresh"}
          </Button>
          {metrics && (
            <Chip
              icon={<NetworkCheck />}
              label={`System ${metrics.systemHealth}`}
              color={getHealthColor(metrics.systemHealth) as any}
              variant="outlined"
            />
          )}
        </Box>
      </Box>

      {/* System Metrics Overview */}
      {metrics && (
        <Grid container spacing={3} sx={{ mb: 4 }}>
          <Grid size={{ xs: 12, sm: 6, md: 3 }}>
            <Card>
              <CardContent sx={{ textAlign: "center" }}>
                <People sx={{ fontSize: 40, color: "primary.main", mb: 1 }} />
                <Typography variant="h4" fontWeight="bold">
                  {metrics.totalUsers}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Total Users
                </Typography>
                <Typography variant="caption" color="success.main">
                  {metrics.activeUsers} active
                </Typography>
              </CardContent>
            </Card>
          </Grid>

          <Grid size={{ xs: 12, sm: 6, md: 3 }}>
            <Card>
              <CardContent sx={{ textAlign: "center" }}>
                <EmojiEvents
                  sx={{ fontSize: 40, color: "secondary.main", mb: 1 }}
                />
                <Typography variant="h4" fontWeight="bold">
                  {metrics.totalTournaments}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Tournaments
                </Typography>
                <Typography variant="caption" color="success.main">
                  {metrics.activeTournaments} active
                </Typography>
              </CardContent>
            </Card>
          </Grid>

          <Grid size={{ xs: 12, sm: 6, md: 3 }}>
            <Card>
              <CardContent sx={{ textAlign: "center" }}>
                <Memory sx={{ fontSize: 40, color: "warning.main", mb: 1 }} />
                <Typography variant="h4" fontWeight="bold">
                  {metrics.memoryUsage}%
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Memory Usage
                </Typography>
                <LinearProgress
                  variant="determinate"
                  value={metrics.memoryUsage}
                  sx={{ mt: 1 }}
                  color={metrics.memoryUsage > 80 ? "error" : "primary"}
                />
              </CardContent>
            </Card>
          </Grid>

          <Grid size={{ xs: 12, sm: 6, md: 3 }}>
            <Card>
              <CardContent sx={{ textAlign: "center" }}>
                <Speed sx={{ fontSize: 40, color: "info.main", mb: 1 }} />
                <Typography variant="h4" fontWeight="bold">
                  {metrics.apiResponseTime}ms
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  API Response
                </Typography>
                <Typography variant="caption" color="success.main">
                  Excellent
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        </Grid>
      )}

      {/* Tab Navigation */}
      <Paper sx={{ mb: 3 }}>
        <Tabs
          value={activeTab}
          onChange={(_, newValue) => setActiveTab(newValue)}
          sx={{ borderBottom: 1, borderColor: "divider" }}
          variant="scrollable"
          scrollButtons="auto"
        >
          <Tab label="System Overview" icon={<Dashboard />} />
          <Tab label="User Management" icon={<People />} />
          <Tab label="System Alerts" icon={<Warning />} />
          <Tab label="Settings" icon={<Settings />} />
        </Tabs>
      </Paper>

      {/* Tab Content */}
      <Box>
        {/* System Overview Tab */}
        {activeTab === 0 && (
          <Grid container spacing={3}>
            <Grid size={{ xs: 12, md: 8 }}>
              <Card>
                <CardContent>
                  <Typography variant="h6" gutterBottom>
                    System Performance
                  </Typography>
                  <Box sx={{ mb: 2 }}>
                    <Typography variant="body2" color="text.secondary">
                      CPU Usage: {metrics?.cpuUsage}%
                    </Typography>
                    <LinearProgress
                      variant="determinate"
                      value={metrics?.cpuUsage || 0}
                      sx={{ mb: 1 }}
                    />
                  </Box>
                  <Box sx={{ mb: 2 }}>
                    <Typography variant="body2" color="text.secondary">
                      Disk Usage: {metrics?.diskUsage}%
                    </Typography>
                    <LinearProgress
                      variant="determinate"
                      value={metrics?.diskUsage || 0}
                      sx={{ mb: 1 }}
                    />
                  </Box>
                  <Alert severity="info">
                    All systems operating within normal parameters.
                  </Alert>
                </CardContent>
              </Card>
            </Grid>

            <Grid size={{ xs: 12, md: 4 }}>
              <Card>
                <CardContent>
                  <Typography variant="h6" gutterBottom>
                    Quick Actions
                  </Typography>
                  <Box
                    sx={{ display: "flex", flexDirection: "column", gap: 1 }}
                  >
                    <Button variant="outlined" startIcon={<People />}>
                      View All Users
                    </Button>
                    <Button variant="outlined" startIcon={<EmojiEvents />}>
                      Manage Tournaments
                    </Button>
                    <Button variant="outlined" startIcon={<Assessment />}>
                      System Reports
                    </Button>
                    <Button variant="outlined" startIcon={<Settings />}>
                      System Settings
                    </Button>
                  </Box>
                </CardContent>
              </Card>
            </Grid>
          </Grid>
        )}

        {/* User Management Tab */}
        {activeTab === 1 && (
          <Card>
            <CardContent>
              <Box
                sx={{
                  display: "flex",
                  justifyContent: "space-between",
                  alignItems: "center",
                  mb: 3,
                }}
              >
                <Typography variant="h6">User Management</Typography>
                <Button variant="contained" startIcon={<PersonAdd />}>
                  Add User
                </Button>
              </Box>

              <TableContainer>
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>User</TableCell>
                      <TableCell>Level</TableCell>
                      <TableCell>Credits</TableCell>
                      <TableCell>Status</TableCell>
                      <TableCell>Last Activity</TableCell>
                      <TableCell>Actions</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {users.map((user) => (
                      <TableRow key={user.id}>
                        <TableCell>
                          <Box
                            sx={{
                              display: "flex",
                              alignItems: "center",
                              gap: 2,
                            }}
                          >
                            <Avatar sx={{ bgcolor: "primary.main" }}>
                              {user.username[0].toUpperCase()}
                            </Avatar>
                            <Box>
                              <Typography variant="body2" fontWeight="bold">
                                {user.full_name}
                              </Typography>
                              <Typography
                                variant="caption"
                                color="text.secondary"
                              >
                                @{user.username}
                              </Typography>
                            </Box>
                          </Box>
                        </TableCell>
                        <TableCell>
                          <Chip label={`Level ${user.level}`} size="small" />
                        </TableCell>
                        <TableCell>{user.credits}</TableCell>
                        <TableCell>
                          <Chip
                            label={user.is_active ? "Active" : "Inactive"}
                            color={user.is_active ? "success" : "default"}
                            size="small"
                          />
                        </TableCell>
                        <TableCell>
                          {formatLastActivity(user.last_activity)}
                        </TableCell>
                        <TableCell>
                          <IconButton
                            size="small"
                            onClick={() => {
                              setSelectedUser(user);
                              setUserDialogOpen(true);
                            }}
                          >
                            <Edit />
                          </IconButton>
                          <IconButton
                            size="small"
                            onClick={() => handleUserAction("block", user.id)}
                          >
                            <Block />
                          </IconButton>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
            </CardContent>
          </Card>
        )}

        {/* System Alerts Tab */}
        {activeTab === 2 && (
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                System Alerts
              </Typography>
              <List>
                {alerts.map((alert) => (
                  <ListItem key={alert.id} divider>
                    <ListItemIcon>
                      {alert.type === "error" && <Error color="error" />}
                      {alert.type === "warning" && <Warning color="warning" />}
                      {alert.type === "info" && <Info color="info" />}
                      {alert.type === "success" && (
                        <CheckCircle color="success" />
                      )}
                    </ListItemIcon>
                    <ListItemText
                      primary={alert.title}
                      secondary={
                        <Box>
                          <Typography variant="body2" color="text.secondary">
                            {alert.message}
                          </Typography>
                          <Typography variant="caption" color="text.secondary">
                            {new Date(alert.timestamp).toLocaleString()}
                          </Typography>
                        </Box>
                      }
                    />
                    <Chip
                      label={alert.resolved ? "Resolved" : "Active"}
                      color={alert.resolved ? "success" : "warning"}
                      size="small"
                    />
                  </ListItem>
                ))}
              </List>
            </CardContent>
          </Card>
        )}

        {/* Settings Tab */}
        {activeTab === 3 && (
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                System Settings
              </Typography>
              <Alert severity="info">
                System settings will be implemented in a future update.
              </Alert>
            </CardContent>
          </Card>
        )}
      </Box>

      {/* User Edit Dialog */}
      <Dialog
        open={userDialogOpen}
        onClose={() => setUserDialogOpen(false)}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle>Edit User</DialogTitle>
        <DialogContent>
          {selectedUser && (
            <Box
              sx={{ pt: 2, display: "flex", flexDirection: "column", gap: 2 }}
            >
              <TextField
                label="Full Name"
                defaultValue={selectedUser.full_name}
                fullWidth
              />
              <TextField
                label="Email"
                defaultValue={selectedUser.email}
                fullWidth
              />
              <TextField
                label="Credits"
                type="number"
                defaultValue={selectedUser.credits}
                fullWidth
              />
              <FormControl fullWidth>
                <InputLabel>Status</InputLabel>
                <Select
                  value={selectedUser.is_active ? "active" : "inactive"}
                  label="Status"
                >
                  <MenuItem value="active">Active</MenuItem>
                  <MenuItem value="inactive">Inactive</MenuItem>
                </Select>
              </FormControl>
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setUserDialogOpen(false)}>Cancel</Button>
          <Button variant="contained" onClick={() => setUserDialogOpen(false)}>
            Save Changes
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default AdminPanel;


==== Page Component: AdminPanel.tsx ==== (frontend/src/pages/AdminPanel.tsx)
// AdminPanel.tsx - ENHANCED DEBUG VERSION
// Updated with comprehensive debugging for admin access issues

import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useSafeAuth } from "../SafeAuthContext";

const AdminPanel: React.FC = () => {
  console.log("🚀 ADMIN PANEL LOADED"); // ✅ ENHANCED: More visible log
  const navigate = useNavigate();
  const { state } = useSafeAuth();
  const [activeTab, setActiveTab] = useState(0);

  // ✅ ENHANCED: Comprehensive admin access debugging
  useEffect(() => {
    console.log("=".repeat(50));
    console.log("🔍 ADMIN PANEL - COMPREHENSIVE DEBUG");
    console.log("=".repeat(50));
    
    // Basic state information
    console.log("📊 Auth State:", {
      isAuthenticated: state.isAuthenticated,
      loading: state.loading,
      hasUser: !!state.user,
      error: state.error
    });
    
    // User object details
    if (state.user) {
      console.log("👤 User Details:", {
        id: state.user.id,
        username: state.user.username,
        email: state.user.email,
        user_type: state.user.user_type,
        is_admin: state.user.is_admin
      });
      
      // ✅ ENHANCED: All possible admin checks
      const adminChecks = {
        byUserType: state.user.user_type === "admin",
        byModeratorType: state.user.user_type === "moderator", 
        byIsAdmin: state.user.is_admin === true,
        finalComputed: state.user?.user_type === "admin" || 
                      state.user?.user_type === "moderator" || 
                      state.user?.is_admin === true
      };
      
      console.log("🛡️ Admin Access Checks:", adminChecks);
      
      // ✅ ENHANCED: Raw user object from API
      console.log("🔬 RAW User Object Keys:", Object.keys(state.user));
      console.log("🧪 RAW User Object:", state.user);
      
    } else {
      console.log("❌ No user object found in state");
    }
    
    console.log("=".repeat(50));
    
    // ✅ ENHANCED: Wait for auth to complete before checking admin
    if (state.loading) {
      console.log("⏳ Still loading authentication state, waiting...");
      return;
    }
    
    if (!state.user) {
      console.log("🚫 No user found, redirecting to login");
      navigate("/login");
      return;
    }
    
    // ✅ ENHANCED: Multiple admin check strategies
    const isAdmin = state.user?.user_type === "admin" || 
                   state.user?.user_type === "moderator" || 
                   state.user?.is_admin === true;
    
    console.log("🎯 FINAL ADMIN DECISION:", isAdmin);
    
    if (!isAdmin) {
      console.log("🚫 ACCESS DENIED: User is not admin");
      console.log("📝 Redirect reason:", {
        user_type: state.user?.user_type,
        is_admin: state.user?.is_admin,
        expected: "admin or moderator"
      });
      
      alert(`Admin access denied!\n\nCurrent user type: ${state.user?.user_type}\nIs admin: ${state.user?.is_admin}\n\nExpected: admin or moderator`);
      
      navigate("/dashboard");
      return;
    }
    
    console.log("✅ ADMIN ACCESS GRANTED - Welcome to admin panel!");
    
  }, [state, navigate]);

  // ✅ ENHANCED: Loading states
  if (state.loading) {
    return (
      <div style={{ padding: "20px", textAlign: "center" }}>
        <h2>Loading Admin Panel...</h2>
        <p>Verifying admin permissions...</p>
      </div>
    );
  }

  if (!state.user) {
    return (
      <div style={{ padding: "20px", textAlign: "center" }}>
        <h2>Authentication Required</h2>
        <p>Redirecting to login...</p>
      </div>
    );
  }

  // ✅ ENHANCED: Admin access verification with detailed feedback
  const isAdmin = state.user?.user_type === "admin" || 
                 state.user?.user_type === "moderator" || 
                 state.user?.is_admin === true;

  if (!isAdmin) {
    return (
      <div style={{ padding: "20px", textAlign: "center" }}>
        <h2>Access Denied</h2>
        <p>Admin privileges required</p>
        <p>Current user type: <strong>{state.user?.user_type || "unknown"}</strong></p>
        <p>Is admin: <strong>{String(state.user?.is_admin)}</strong></p>
        <button onClick={() => navigate("/dashboard")}>
          Return to Dashboard
        </button>
      </div>
    );
  }

  return (
    <div style={{ padding: "20px" }}>
      <h1>🛡️ Admin Panel</h1>
      <div style={{ 
        background: "#e8f5e8", 
        padding: "10px", 
        borderRadius: "5px",
        marginBottom: "20px" 
      }}>
        <p><strong>✅ Admin Access Confirmed</strong></p>
        <p>Welcome, {state.user.full_name} ({state.user.user_type})</p>
        <p>Admin status: {String(state.user.is_admin)}</p>
      </div>
      
      {/* Rest of admin panel content will go here */}
      <div style={{ border: "1px solid #ccc", padding: "20px", borderRadius: "5px" }}>
        <h3>Admin Panel Content</h3>
        <p>Admin panel functionality will be implemented here.</p>
        <p>Current admin user: <strong>{state.user.username}</strong></p>
        <p>User type: <strong>{state.user.user_type}</strong></p>
        <p>Credits: <strong>{state.user.credits}</strong></p>
      </div>
    </div>
  );
};

export default AdminPanel;

==== Page Component: Chat.tsx ==== (frontend/src/pages/Chat.tsx)
// === Chat.tsx - Chat Page Component ===
import React from 'react';
import ChatWindow from '../components/chat/ChatWindow';
import { useSafeAuth } from '../SafeAuthContext';

const Chat: React.FC = () => {
  const { state } = useSafeAuth();

  return (
    <div style={{ 
      padding: '20px', 
      maxWidth: '1200px', 
      margin: '0 auto',
      minHeight: '100vh',
      backgroundColor: '#f5f5f5'
    }}>
      <div style={{
        display: 'flex',
        flexDirection: 'column',
        gap: '20px'
      }}>
        
        {/* Header */}
        <div style={{
          backgroundColor: 'white',
          padding: '20px',
          borderRadius: '8px',
          boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
        }}>
          <h1 style={{ margin: 0, color: '#333' }}>
            💬 Real-time Chat
          </h1>
          <p style={{ margin: '8px 0 0', color: '#666', fontSize: '14px' }}>
            Connect with other players in real-time
          </p>
        </div>

        {/* Chat Interface */}
        <div style={{
          display: 'flex',
          gap: '20px',
          flexWrap: 'wrap'
        }}>
          
          {/* Main Chat */}
          <div style={{ 
            flex: 1, 
            minWidth: '400px',
            backgroundColor: 'white',
            borderRadius: '8px',
            boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
          }}>
            <ChatWindow 
              roomId="global_chat"
              height="600px"
            />
          </div>

          {/* Sidebar - Chat Info */}
          <div style={{
            width: '300px',
            backgroundColor: 'white',
            borderRadius: '8px',
            padding: '20px',
            boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
            alignSelf: 'flex-start'
          }}>
            <h3 style={{ margin: '0 0 16px', color: '#333' }}>
              Chat Information
            </h3>
            
            {state.isAuthenticated ? (
              <div style={{ fontSize: '14px', color: '#666', lineHeight: '1.5' }}>
                <div style={{ marginBottom: '12px' }}>
                  <strong>Logged in as:</strong><br />
                  {state.user?.username || 'Unknown'}
                </div>
                
                <div style={{ marginBottom: '12px' }}>
                  <strong>Room:</strong><br />
                  Global Chat
                </div>
                
                <div style={{ marginBottom: '12px' }}>
                  <strong>Features:</strong>
                  <ul style={{ margin: '4px 0', paddingLeft: '16px' }}>
                    <li>Real-time messaging</li>
                    <li>Auto-reconnection</li>
                    <li>Message history</li>
                    <li>User presence</li>
                  </ul>
                </div>

                <div style={{ 
                  marginTop: '20px', 
                  padding: '12px', 
                  backgroundColor: '#f8f9fa', 
                  borderRadius: '4px',
                  fontSize: '12px'
                }}>
                  <strong>Tips:</strong><br />
                  • Messages are limited to 500 characters<br />
                  • Be respectful to other players<br />
                  • Connection status is shown in the header
                </div>
              </div>
            ) : (
              <div style={{ 
                padding: '20px',
                textAlign: 'center',
                color: '#666',
                fontSize: '14px'
              }}>
                <p>Please log in to use the chat feature</p>
              </div>
            )}
          </div>
          
        </div>

        {/* Debug Information (only in development) */}
        {process.env.NODE_ENV === 'development' && (
          <div style={{
            backgroundColor: '#fff3cd',
            border: '1px solid #ffeaa7',
            borderRadius: '8px',
            padding: '16px'
          }}>
            <h4 style={{ margin: '0 0 8px', color: '#856404' }}>
              🔧 Development Debug Info
            </h4>
            <div style={{ fontSize: '12px', color: '#856404', fontFamily: 'monospace' }}>
              <div>API URL: {process.env.REACT_APP_API_URL || 'default'}</div>
              <div>WebSocket URL: {process.env.REACT_APP_WEBSOCKET_URL || 'auto-detected'}</div>
              <div>User ID: {state.user?.id || 'not logged in'}</div>
              <div>Auth Status: {state.isAuthenticated ? 'authenticated' : 'not authenticated'}</div>
            </div>
          </div>
        )}
        
      </div>
    </div>
  );
};

export default Chat;

==== Page Component: CreditsPage.tsx ==== (frontend/src/pages/CreditsPage.tsx)
import React, { useState } from "react";
import {
  Box,
  Typography,
  Grid,
  Card,
  CardContent,
  Button,
  IconButton,
  Tooltip,
  Snackbar,
  Alert,
  Breadcrumbs,
  Link as MuiLink,
} from "@mui/material";
import { ArrowBack, Home, AccountBalanceWallet } from "@mui/icons-material";
import { Link, useNavigate } from "react-router-dom";
import { CouponRedemptionResponse } from "../services/api";
import CreditBalance from "../components/credits/CreditBalance";
import CouponRedemption from "../components/credits/CouponRedemption";
import AvailableCoupons from "../components/credits/AvailableCoupons";
import CreditPurchase from "../components/credits/CreditPurchase";

const CreditsPage: React.FC = () => {
  const navigate = useNavigate();
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const [snackbarOpen, setSnackbarOpen] = useState(false);

  const handleCouponSuccess = (response: CouponRedemptionResponse) => {
    setSuccessMessage(
      `🎉 ${response.coupon_name} redeemed! +${response.credits_awarded} credits`
    );
    setSnackbarOpen(true);
  };

  const handleCreditBalanceUpdate = (newBalance: number) => {
    console.log("Credit balance updated:", newBalance);
  };

  return (
    <Box>
      {/* Header with navigation */}
      <Box
        sx={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          mb: 3,
        }}
      >
        <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
          <Tooltip title="Back to Dashboard">
            <IconButton onClick={() => navigate("/dashboard")}>
              <ArrowBack />
            </IconButton>
          </Tooltip>

          <Box>
            <Typography variant="h4" component="h1" fontWeight="bold">
              💎 Credits & Coupons
            </Typography>

            <Breadcrumbs aria-label="breadcrumb" sx={{ mt: 1 }}>
              <MuiLink
                component={Link}
                to="/dashboard"
                underline="hover"
                color="inherit"
                sx={{ display: "flex", alignItems: "center" }}
              >
                <Home sx={{ mr: 0.5 }} fontSize="small" />
                Dashboard
              </MuiLink>
              <Typography
                color="text.primary"
                sx={{ display: "flex", alignItems: "center" }}
              >
                <AccountBalanceWallet sx={{ mr: 0.5 }} fontSize="small" />
                Credits
              </Typography>
            </Breadcrumbs>
          </Box>
        </Box>

        <Button
          variant="outlined"
          startIcon={<ArrowBack />}
          onClick={() => navigate("/dashboard")}
          sx={{ display: { xs: "none", sm: "flex" } }}
        >
          Back to Dashboard
        </Button>
      </Box>

      <Grid container spacing={4}>
        {/* Credit Balance Section */}
        <Grid item xs={12} lg={4}>
          <Box sx={{ position: "sticky", top: 20 }}>
            <CreditBalance
              onAddCredits={() => {
                document.getElementById("purchase-section")?.scrollIntoView({
                  behavior: "smooth",
                  block: "center",
                });
              }}
              onViewHistory={() => console.log("View history clicked")}
              showHistoryButton={true}
              showRefreshButton={true}
              showAddButton={true}
            />
          </Box>
        </Grid>

        {/* Main Content */}
        <Grid item xs={12} lg={8}>
          <Grid container spacing={3}>
            {/* Coupon Redemption */}
            <Grid item xs={12}>
              <CouponRedemption
                onSuccess={handleCouponSuccess}
                onBalanceUpdate={handleCreditBalanceUpdate}
              />
            </Grid>

            {/* Available Coupons for Development */}
            <Grid item xs={12}>
              <AvailableCoupons
                developmentMode={process.env.NODE_ENV === "development"}
                onCouponSelect={(code) => {
                  // Auto-fill the coupon code in redemption form
                  const couponInput = document.querySelector(
                    'input[placeholder*="coupon"]'
                  ) as HTMLInputElement;
                  if (couponInput) {
                    couponInput.value = code;
                    couponInput.focus();

                    // Trigger change event
                    const event = new Event("input", { bubbles: true });
                    couponInput.dispatchEvent(event);
                  }
                }}
              />
            </Grid>

            {/* Credit Purchase Section */}
            <Grid item xs={12} id="purchase-section">
              <Card>
                <CardContent>
                  <Typography variant="h6" gutterBottom fontWeight="bold">
                    💳 Purchase Credits
                  </Typography>
                  <Typography
                    variant="body2"
                    color="text.secondary"
                    sx={{ mb: 3 }}
                  >
                    Need more credits? Choose from our credit packages below.
                  </Typography>
                  <CreditPurchase />
                </CardContent>
              </Card>
            </Grid>
          </Grid>
        </Grid>
      </Grid>

      {/* Success Notification */}
      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={() => setSnackbarOpen(false)}
        anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
      >
        <Alert
          onClose={() => setSnackbarOpen(false)}
          severity="success"
          sx={{ width: "100%" }}
        >
          {successMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default CreditsPage;


==== Page Component: Dashboard.tsx ==== (frontend/src/pages/Dashboard.tsx)
import React, { useState, useEffect, memo, useCallback, useMemo } from "react";
import {
  Box,
  Typography,
  Grid,
  Card,
  CardContent,
  Button,
  LinearProgress,
  Alert,
  Fade,
  IconButton,
  Tooltip,
  Snackbar,
} from "@mui/material";
import {
  EmojiEvents,
  Person,
  TrendingUp,
  Refresh,
  Add,
  AccountBalanceWallet,
} from "@mui/icons-material";
import { useSafeAuth } from "../SafeAuthContext";
import { useNavigate } from "react-router-dom";
import { tournamentService, CouponRedemptionResponse } from "../services/api";
import CreditBalance from "../components/credits/CreditBalance";
import CouponRedemption from "../components/credits/CouponRedemption";
import AvailableCoupons from "../components/credits/AvailableCoupons";

interface DashboardStats {
  totalTournaments: number;
  activeTournaments: number;
  recentActivity: string[];
}

const Dashboard = memo(() => {
  // 🔥 KRITIKUS JAVÍTÁS: refreshStats kinyerése az SafeAuthContext-ből
  const { state, refreshStats } = useSafeAuth();
  const navigate = useNavigate();
  const [stats, setStats] = useState<DashboardStats | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const [snackbarOpen, setSnackbarOpen] = useState(false);

  const loadDashboardStats = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const tournaments = await tournamentService.getTournaments();
      const completedTournaments = tournaments.filter((t: any) => t.status === "completed").length;
      const upcomingTournaments = tournaments.filter((t: any) => t.status === "registration").length;
      
      setStats({
        totalTournaments: tournaments.length,
        activeTournaments: upcomingTournaments,
        recentActivity: [
          `⚽ ${completedTournaments} tournaments completed`,
          `🏆 ${upcomingTournaments} tournaments open for registration`,
          `📊 ${state.user?.games_won || 0} games won this season`,
          `🎯 ${Math.round(((state.user?.games_won || 0) / Math.max((state.user?.games_won || 0) + (state.user?.games_lost || 0), 1)) * 100)}% win rate`,
        ],
      });
    } catch (err: any) {
      setError(err.message || "Failed to load dashboard");
    } finally {
      setLoading(false);
    }
  }, [state.user]);

  useEffect(() => {
    loadDashboardStats();
  }, [loadDashboardStats]);

  // 🎯 JAVÍTOTT: Most már megfelelően frissíti az auth context user adatait
  const handleCouponSuccess = useCallback(
    async (response: CouponRedemptionResponse) => {
      setSuccessMessage(
        `🎉 ${response.coupon_name} redeemed! +${response.credits_awarded} credits`
      );
      setSnackbarOpen(true);

      // 🚀 KULCS JAVÍTÁS: Azonnal frissíti a user adatokat az auth context-ben
      try {
        await refreshStats();
        console.log("✅ User stats frissítve kupon beváltás után");
      } catch (error) {
        console.error("❌ User stats frissítés sikertelen:", error);

        // Fallback: késleltetett frissítés ha az azonnali nem sikerült
        setTimeout(async () => {
          try {
            await refreshStats();
            console.log("✅ User stats frissítve (fallback)");
          } catch (fallbackError) {
            console.error(
              "❌ Fallback frissítés is sikertelen:",
              fallbackError
            );
          }
        }, 1500);
      }

      // Dashboard stats frissítése is
      setTimeout(() => {
        loadDashboardStats();
      }, 1000);
    },
    [refreshStats, loadDashboardStats]
  );

  const handleCreditBalanceUpdate = useCallback((newBalance: number) => {
    // Opcionális: Direkt user context frissítés ha szükséges
    console.log("Credit balance frissítve:", newBalance);
  }, []);

  const userStats = useMemo(
    () => [
      {
        title: "Level",
        value: state.user?.level || 1,
        icon: <TrendingUp />,
        color: "primary" as const,
        progress: (state.user?.xp || 0) % 100,
      },
      {
        title: "Credits",
        value: state.user?.credits || 0, // 📊 Ez most már valós időben frissül!
        icon: <EmojiEvents />,
        color: "secondary" as const,
        action: () => {
          document.getElementById("coupon-section")?.scrollIntoView({
            behavior: "smooth",
            block: "center",
          });
        },
      },
      {
        title: "Games Played",
        value: state.user?.games_played || 0,
        icon: <Person />,
        color: "success" as const,
        winRate: state.user?.games_played
          ? ((state.user.games_won || 0) / state.user.games_played) * 100
          : 0,
      },
    ],
    [state.user]
  );

  return (
    <Box>
      <Box
        sx={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          flexDirection: { xs: "column", md: "row" },
          gap: 2,
          mb: 3,
        }}
      >
        <Typography variant="h4" component="h1" fontWeight="bold">
          Welcome back, {state.user?.full_name || state.user?.username}!
        </Typography>

        <Box sx={{ display: "flex", gap: 1 }}>
          <Tooltip title="Refresh data">
            <IconButton
              onClick={() => {
                loadDashboardStats();
                refreshStats(); // 🔄 User stats frissítése is
              }}
              disabled={loading}
            >
              <Refresh />
            </IconButton>
          </Tooltip>
        </Box>
      </Box>

      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}

      <Grid container spacing={3}>
        {userStats.map((stat, index) => (
          <Grid key={`user-stat-${index}`} size={{ xs: 12, sm: 6, md: 4 }}>
            <Fade in timeout={300 * (index + 1)}>
              <Card
                sx={{
                  height: "100%",
                  cursor: stat.action ? "pointer" : "default",
                  transition: "transform 0.2s, box-shadow 0.2s",
                  "&:hover": stat.action
                    ? {
                        transform: "translateY(-4px)",
                        boxShadow: 3,
                      }
                    : {},
                }}
                onClick={stat.action}
              >
                <CardContent>
                  <Box
                    sx={{
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "space-between",
                      mb: 2,
                    }}
                  >
                    <Typography color="text.secondary" variant="h6">
                      {stat.title}
                    </Typography>
                    <Box sx={{ color: `${stat.color}.main` }}>{stat.icon}</Box>
                  </Box>

                  <Typography
                    variant="h4"
                    component="div"
                    fontWeight="bold"
                    color={`${stat.color}.main`}
                  >
                    {stat.value}
                  </Typography>

                  {stat.progress !== undefined && (
                    <Box sx={{ mt: 2 }}>
                      <LinearProgress
                        variant="determinate"
                        value={stat.progress}
                        color={stat.color}
                        sx={{ height: 8, borderRadius: 4 }}
                      />
                      <Typography
                        variant="caption"
                        color="text.secondary"
                        sx={{ mt: 1, display: "block" }}
                      >
                        {Math.round(stat.progress)}% to next level
                      </Typography>
                    </Box>
                  )}

                  {stat.winRate !== undefined && (
                    <Typography
                      variant="caption"
                      color="text.secondary"
                      sx={{ mt: 1, display: "block" }}
                    >
                      Win Rate: {stat.winRate.toFixed(1)}%
                    </Typography>
                  )}

                  {stat.action && (
                    <Typography
                      variant="caption"
                      color="primary"
                      sx={{ mt: 1, display: "block" }}
                    >
                      Click to manage →
                    </Typography>
                  )}
                </CardContent>
              </Card>
            </Fade>
          </Grid>
        ))}
      </Grid>

      {/* Football Gaming Stats */}
      {stats && (
        <Box sx={{ mt: 4 }}>
          <Typography variant="h6" gutterBottom>
            ⚽ Football Gaming Overview
          </Typography>
          <Grid container spacing={2}>
            <Grid size={{ xs: 6, md: 3 }}>
              <Card>
                <CardContent sx={{ textAlign: "center" }}>
                  <Typography variant="h5" color="primary">
                    {stats.totalTournaments}
                  </Typography>
                  <Typography color="text.secondary">
                    🏆 Tournaments Available
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
            <Grid size={{ xs: 6, md: 3 }}>
              <Card>
                <CardContent sx={{ textAlign: "center" }}>
                  <Typography variant="h5" color="success.main">
                    {stats.activeTournaments}
                  </Typography>
                  <Typography color="text.secondary">🔥 Open for Registration</Typography>
                </CardContent>
              </Card>
            </Grid>
            <Grid size={{ xs: 6, md: 3 }}>
              <Card>
                <CardContent sx={{ textAlign: "center" }}>
                  <Typography variant="h5" color="warning.main">
                    {state.user?.games_won || 0}
                  </Typography>
                  <Typography color="text.secondary">⚽ Games Won</Typography>
                </CardContent>
              </Card>
            </Grid>
            <Grid size={{ xs: 6, md: 3 }}>
              <Card>
                <CardContent sx={{ textAlign: "center" }}>
                  <Typography variant="h5" color="info.main">
                    {Math.round(((state.user?.games_won || 0) / Math.max((state.user?.games_won || 0) + (state.user?.games_lost || 0), 1)) * 100)}%
                  </Typography>
                  <Typography color="text.secondary">🎯 Win Rate</Typography>
                </CardContent>
              </Card>
            </Grid>
          </Grid>
        </Box>
      )}

      {/* Recent Activity */}
      {stats && stats.recentActivity && (
        <Box sx={{ mt: 4 }}>
          <Typography variant="h6" gutterBottom>
            📈 Recent Activity
          </Typography>
          <Card>
            <CardContent>
              {stats.recentActivity.map((activity, index) => (
                <Typography key={index} sx={{ mb: 1 }}>
                  {activity}
                </Typography>
              ))}
            </CardContent>
          </Card>
        </Box>
      )}

      {/* Quick Actions */}
      <Box sx={{ mt: 4 }}>
        <Typography variant="h6" gutterBottom>
          Quick Actions
        </Typography>
        <Grid container spacing={2}>
          <Grid size={{ xs: 12, sm: 6, md: 4 }}>
            <Button
              variant="contained"
              fullWidth
              startIcon={<Add />}
              onClick={() => navigate("/tournaments")}
              sx={{ py: 1.5 }}
            >
              Join Tournament
            </Button>
          </Grid>
          <Grid size={{ xs: 12, sm: 6, md: 4 }}>
            <Button
              variant="contained"
              fullWidth
              startIcon={<AccountBalanceWallet />}
              onClick={() => navigate("/credits")}
              sx={{ py: 1.5 }}
              color="secondary"
            >
              💎 Manage Credits
            </Button>
          </Grid>
          <Grid size={{ xs: 12, sm: 6, md: 4 }}>
            <Button
              variant="outlined"
              fullWidth
              startIcon={<Person />}
              onClick={() => navigate("/profile")}
              sx={{ py: 1.5 }}
            >
              View Profile
            </Button>
          </Grid>
        </Grid>
      </Box>

      {/* Coupon System Section */}
      <Box id="coupon-section" sx={{ mt: 4 }}>
        <Typography variant="h5" component="h2" fontWeight="bold" gutterBottom>
          💎 Credits & Coupons
        </Typography>

        <Grid container spacing={3}>
          {/* Credit Balance */}
          <Grid size={{ xs: 12, md: 4 }}>
            <CreditBalance
              onAddCredits={() => navigate("/credits")}
              onViewHistory={() => navigate("/credits")}
              showHistoryButton={true}
            />
          </Grid>

          {/* Coupon Redemption */}
          <Grid size={{ xs: 12, md: 8 }}>
            <CouponRedemption
              onSuccess={handleCouponSuccess} // 🎯 Ez most már megfelelően frissíti az auth context-et
              onBalanceUpdate={handleCreditBalanceUpdate}
            />
          </Grid>

          {/* Available Coupons (Development) */}
          <Grid size={12}>
            <AvailableCoupons
              developmentMode={process.env.NODE_ENV === "development"}
              onCouponSelect={(code) => {
                // Auto-fill the coupon code in redemption form
                const couponInput = document.querySelector(
                  'input[placeholder*="coupon"]'
                ) as HTMLInputElement;
                if (couponInput) {
                  couponInput.value = code;
                  couponInput.focus();

                  // Trigger change event
                  const event = new Event("input", { bubbles: true });
                  couponInput.dispatchEvent(event);
                }
              }}
            />
          </Grid>
        </Grid>
      </Box>

      {/* Success Notification Snackbar */}
      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={() => setSnackbarOpen(false)}
        message={successMessage}
        anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
      />
    </Box>
  );
});

export default Dashboard;


==== Page Component: GameResults.tsx ==== (frontend/src/pages/GameResults.tsx)
import React, { useState } from "react";
import {
  Box,
  Typography,
  IconButton,
  Tabs,
  Tab,
  useTheme,
  useMediaQuery,
} from "@mui/material";
import {
  ArrowBack,
  History,
  Analytics,
  EmojiEvents,
} from "@mui/icons-material";
import { useNavigate } from "react-router-dom";
import GameHistory from "../components/game-results/GameHistory";
import Statistics from "../components/game-results/Statistics";
import MatchResults from "../components/game-results/MatchResults";

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel({ children, value, index }: TabPanelProps) {
  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`gameresults-tabpanel-${index}`}
      aria-labelledby={`gameresults-tab-${index}`}
    >
      {value === index && <Box sx={{ py: 3 }}>{children}</Box>}
    </div>
  );
}

const GameResults: React.FC = () => {
  const navigate = useNavigate();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("md"));
  const [activeTab, setActiveTab] = useState(0);

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setActiveTab(newValue);
  };

  const tabs = [
    {
      label: "Match History",
      icon: <History />,
      component: <GameHistory />,
    },
    {
      label: "Statistics",
      icon: <Analytics />,
      component: <Statistics />,
    },
    {
      label: "Recent Results",
      icon: <EmojiEvents />,
      component: <MatchResults />,
    },
  ];

  return (
    <Box sx={{ p: { xs: 2, md: 3 } }}>
      {/* Header */}
      <Box sx={{ display: "flex", alignItems: "center", mb: 4 }}>
        <IconButton
          onClick={() => navigate("/dashboard")}
          sx={{ mr: 2 }}
          aria-label="Back to dashboard"
        >
          <ArrowBack />
        </IconButton>
        <Typography variant="h4" component="h1" fontWeight="bold">
          Game Results 📊
        </Typography>
      </Box>

      {/* Tabs Navigation */}
      <Box sx={{ borderBottom: 1, borderColor: "divider", mb: 3 }}>
        <Tabs
          value={activeTab}
          onChange={handleTabChange}
          variant={isMobile ? "fullWidth" : "standard"}
          sx={{
            "& .MuiTab-root": {
              minHeight: 64,
              textTransform: "none",
              fontSize: "1rem",
              fontWeight: 600,
            },
          }}
        >
          {tabs.map((tab, index) => (
            <Tab
              key={index}
              label={isMobile ? undefined : tab.label}
              icon={tab.icon}
              iconPosition={isMobile ? "top" : "start"}
              aria-label={tab.label}
              sx={{
                "& .MuiTab-iconWrapper": {
                  mb: isMobile ? 0.5 : 0,
                  mr: isMobile ? 0 : 1,
                },
              }}
            />
          ))}
        </Tabs>
      </Box>

      {/* Tab Content */}
      {tabs.map((tab, index) => (
        <TabPanel key={index} value={activeTab} index={index}>
          {tab.component}
        </TabPanel>
      ))}
    </Box>
  );
};

export default GameResults;


==== Page Component: LocationManagement.tsx ==== (frontend/src/pages/LocationManagement.tsx)
import React, { useState } from "react";
import {
  Box,
  Typography,
  Tabs,
  Tab,
  Paper,
} from "@mui/material";
import {
  LocationOn,
  Schedule,
  Map,
  EmojiEvents,
} from "@mui/icons-material";
import { useSafeAuth } from "../SafeAuthContext";
import LocationManager from "../components/locations/LocationManager";
import AvailabilityCalendar from "../components/locations/AvailabilityCalendar";
import GameBookingIntegration from "../components/locations/GameBookingIntegration";

const LocationManagement: React.FC = () => {
  const { user } = useSafeAuth();
  const [selectedTab, setSelectedTab] = useState(0);
  const [selectedLocationId, setSelectedLocationId] = useState<number | null>(null);
  const [selectedLocationName, setSelectedLocationName] = useState<string>("");

  const handleLocationSelect = (locationId: number, locationName: string) => {
    setSelectedLocationId(locationId);
    setSelectedLocationName(locationName);
    setSelectedTab(1); // Switch to availability tab
  };

  const userRole = user?.user_type === 'admin' || user?.user_type === 'moderator' ? 'admin' : 'user';

  return (
    <Box sx={{ p: 3 }}>
      {/* Header */}
      <Typography 
        variant="h4" 
        component="h1" 
        sx={{ display: "flex", alignItems: "center", gap: 1, mb: 3 }}
      >
        <LocationOn color="primary" />
        Location Services
      </Typography>

      {/* Tabs */}
      <Paper sx={{ mb: 3 }}>
        <Tabs
          value={selectedTab}
          onChange={(_, newValue) => setSelectedTab(newValue)}
          sx={{ borderBottom: 1, borderColor: "divider" }}
        >
          <Tab label="Locations" icon={<LocationOn />} />
          <Tab 
            label={selectedLocationId ? `Availability - ${selectedLocationName}` : "Select Location First"} 
            icon={<Schedule />}
            disabled={!selectedLocationId}
          />
          <Tab label="Game Booking" icon={<EmojiEvents />} />
          <Tab label="Map View" icon={<Map />} disabled />
        </Tabs>
      </Paper>

      {/* Tab Content */}
      <Box>
        {selectedTab === 0 && (
          <LocationManager 
            userRole={userRole}
            onLocationSelect={handleLocationSelect}
          />
        )}
        
        {selectedTab === 1 && selectedLocationId && (
          <AvailabilityCalendar
            locationId={selectedLocationId}
            locationName={selectedLocationName}
          />
        )}
        
        {selectedTab === 2 && (
          <GameBookingIntegration />
        )}
        
        {selectedTab === 3 && (
          <Box sx={{ textAlign: "center", py: 8 }}>
            <Typography variant="h6" color="text.secondary">
              Map View Coming Soon
            </Typography>
            <Typography variant="body2" color="text.secondary">
              Interactive map with location markers will be available in the next update.
            </Typography>
          </Box>
        )}
      </Box>
    </Box>
  );
};

export default LocationManagement;

==== Page Component: Login.tsx ==== (frontend/src/pages/Login.tsx)
import React, { useState } from "react";
import {
  Box,
  Card,
  CardContent,
  TextField,
  Button,
  Typography,
  Tabs,
  Tab,
  Alert,
  IconButton,
  InputAdornment,
  Container,
  CircularProgress,
} from "@mui/material";
import {
  Visibility,
  VisibilityOff,
  SportsSoccer,
  Email,
  Person,
  Lock,
} from "@mui/icons-material";
import { useSafeAuth } from "../SafeAuthContext";

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

const TabPanel: React.FC<TabPanelProps> = ({ children, value, index }) => {
  return (
    <div hidden={value !== index}>
      {value === index && <Box sx={{ pt: 3 }}>{children}</Box>}
    </div>
  );
};

const Login: React.FC = () => {
  const { state, login, register, clearError } = useSafeAuth();
  const [activeTab, setActiveTab] = useState(0);
  const [showPassword, setShowPassword] = useState(false);
  const [formData, setFormData] = useState({
    username: "",
    email: "",
    full_name: "",
    password: "",
    confirmPassword: "",
  });
  const [errors, setErrors] = useState<Record<string, string>>({});

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setActiveTab(newValue);
    setFormData({
      username: "",
      email: "",
      full_name: "",
      password: "",
      confirmPassword: "",
    });
    setErrors({});
    clearError();
  };

  const handleInputChange =
    (field: string) => (event: React.ChangeEvent<HTMLInputElement>) => {
      setFormData((prev) => ({ ...prev, [field]: event.target.value }));
      if (errors[field]) {
        setErrors((prev) => ({ ...prev, [field]: "" }));
      }
      if (state.error) {
        clearError();
      }
    };

  const validateForm = () => {
    const newErrors: Record<string, string> = {};

    if (!formData.username.trim()) {
      newErrors.username = "Username is required";
    }

    if (!formData.password.trim()) {
      newErrors.password = "Password is required";
    }

    if (activeTab === 1) {
      // Register
      if (!formData.full_name.trim()) {
        newErrors.full_name = "Full name is required";
      }

      if (!formData.email.trim()) {
        newErrors.email = "Email is required";
      } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
        newErrors.email = "Email is invalid";
      }

      if (formData.password !== formData.confirmPassword) {
        newErrors.confirmPassword = "Passwords do not match";
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleLoginSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    console.log("🔐 Login attempt initiated");

    if (!validateForm()) return;

    const success = await login({
      username: formData.username,
      password: formData.password,
    });

    if (success) {
      console.log("🔐 Login successful");
      // ✅ SUCCESS: AuthContext will handle redirect automatically
    }
  };

  const handleRegisterSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    console.log("📝 Register attempt initiated");

    if (!validateForm()) return;

    const success = await register({
      username: formData.username,
      email: formData.email,
      full_name: formData.full_name,
      password: formData.password,
    });

    if (success) {
      console.log("📝 Registration successful");
      // ✅ SUCCESS: AuthContext will handle redirect automatically
    }
  };

  return (
    <Box
      sx={{
        minHeight: "100vh",
        background: "linear-gradient(135deg, #0f172a 0%, #1e293b 100%)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        py: 4,
      }}
    >
      <Container maxWidth="sm">
        <Card sx={{ maxWidth: 500, mx: "auto" }}>
          <CardContent sx={{ p: 4 }}>
            <Box sx={{ textAlign: "center", mb: 4 }}>
              <SportsSoccer
                sx={{ fontSize: 60, color: "primary.main", mb: 2 }}
              />
              <Typography
                variant="h4"
                component="h1"
                gutterBottom
                fontWeight="bold"
              >
                LFA Legacy GO
              </Typography>
              <Typography variant="body1" color="text.secondary">
                Football Tournament Platform
              </Typography>
            </Box>

            <Tabs
              value={activeTab}
              onChange={handleTabChange}
              variant="fullWidth"
              sx={{ mb: 3 }}
            >
              <Tab label="Sign In" />
              <Tab label="Sign Up" />
            </Tabs>

            {state.error && (
              <Alert severity="error" sx={{ mb: 3 }}>
                {state.error}
              </Alert>
            )}

            <form
              onSubmit={
                activeTab === 0 ? handleLoginSubmit : handleRegisterSubmit
              }
            >
              <TabPanel value={activeTab} index={0}>
                <Box
                  sx={{ display: "flex", flexDirection: "column", gap: 2.5 }}
                >
                  <TextField
                    label="Username"
                    value={formData.username}
                    onChange={handleInputChange("username")}
                    error={Boolean(errors.username)}
                    helperText={errors.username}
                    disabled={state.loading}
                    fullWidth
                    InputProps={{
                      startAdornment: (
                        <InputAdornment position="start">
                          <Person color="action" />
                        </InputAdornment>
                      ),
                    }}
                  />

                  <TextField
                    label="Password"
                    type={showPassword ? "text" : "password"}
                    value={formData.password}
                    onChange={handleInputChange("password")}
                    error={Boolean(errors.password)}
                    helperText={errors.password}
                    disabled={state.loading}
                    fullWidth
                    InputProps={{
                      startAdornment: (
                        <InputAdornment position="start">
                          <Lock color="action" />
                        </InputAdornment>
                      ),
                      endAdornment: (
                        <InputAdornment position="end">
                          <IconButton
                            onClick={() => setShowPassword(!showPassword)}
                            edge="end"
                          >
                            {showPassword ? <VisibilityOff /> : <Visibility />}
                          </IconButton>
                        </InputAdornment>
                      ),
                    }}
                  />
                </Box>
              </TabPanel>

              <TabPanel value={activeTab} index={1}>
                <Box
                  sx={{ display: "flex", flexDirection: "column", gap: 2.5 }}
                >
                  <TextField
                    label="Full Name"
                    value={formData.full_name}
                    onChange={handleInputChange("full_name")}
                    error={Boolean(errors.full_name)}
                    helperText={errors.full_name}
                    disabled={state.loading}
                    fullWidth
                    InputProps={{
                      startAdornment: (
                        <InputAdornment position="start">
                          <Person color="action" />
                        </InputAdornment>
                      ),
                    }}
                  />

                  <TextField
                    label="Username"
                    value={formData.username}
                    onChange={handleInputChange("username")}
                    error={Boolean(errors.username)}
                    helperText={errors.username}
                    disabled={state.loading}
                    fullWidth
                    InputProps={{
                      startAdornment: (
                        <InputAdornment position="start">
                          <Person color="action" />
                        </InputAdornment>
                      ),
                    }}
                  />

                  <TextField
                    label="Email"
                    type="email"
                    value={formData.email}
                    onChange={handleInputChange("email")}
                    error={Boolean(errors.email)}
                    helperText={errors.email}
                    disabled={state.loading}
                    fullWidth
                    InputProps={{
                      startAdornment: (
                        <InputAdornment position="start">
                          <Email color="action" />
                        </InputAdornment>
                      ),
                    }}
                  />

                  <TextField
                    label="Password"
                    type={showPassword ? "text" : "password"}
                    value={formData.password}
                    onChange={handleInputChange("password")}
                    error={Boolean(errors.password)}
                    helperText={errors.password}
                    disabled={state.loading}
                    fullWidth
                    InputProps={{
                      startAdornment: (
                        <InputAdornment position="start">
                          <Lock color="action" />
                        </InputAdornment>
                      ),
                      endAdornment: (
                        <InputAdornment position="end">
                          <IconButton
                            onClick={() => setShowPassword(!showPassword)}
                            edge="end"
                          >
                            {showPassword ? <VisibilityOff /> : <Visibility />}
                          </IconButton>
                        </InputAdornment>
                      ),
                    }}
                  />

                  <TextField
                    label="Confirm Password"
                    type="password"
                    value={formData.confirmPassword}
                    onChange={handleInputChange("confirmPassword")}
                    error={Boolean(errors.confirmPassword)}
                    helperText={errors.confirmPassword}
                    disabled={state.loading}
                    fullWidth
                    InputProps={{
                      startAdornment: (
                        <InputAdornment position="start">
                          <Lock color="action" />
                        </InputAdornment>
                      ),
                    }}
                  />
                </Box>
              </TabPanel>

              <Button
                type="submit"
                variant="contained"
                size="large"
                fullWidth
                disabled={state.loading}
                sx={{
                  mt: 3,
                  py: 1.5,
                  fontSize: "1.1rem",
                  fontWeight: 600,
                  background: "linear-gradient(135deg, #10b981, #059669)",
                  "&:hover": {
                    background: "linear-gradient(135deg, #059669, #047857)",
                  },
                }}
              >
                {state.loading ? (
                  <CircularProgress size={24} color="inherit" />
                ) : activeTab === 0 ? (
                  "Sign In"
                ) : (
                  "Create Account"
                )}
              </Button>
            </form>
          </CardContent>
        </Card>
      </Container>
    </Box>
  );
};

export default Login;


==== Page Component: Profile.tsx ==== (frontend/src/pages/Profile.tsx)
import React, { useState, useEffect } from "react";
import {
  Box,
  Typography,
  Card,
  CardContent,
  Grid,
  LinearProgress,
  Button,
  Avatar,
  Chip,
  Divider,
  Dialog,
  DialogTitle,
  DialogContent,
  IconButton,
} from "@mui/material";
import {
  Person,
  Edit,
  EmojiEvents,
  SportsScore,
  TrendingUp,
  Security,
  CheckCircle,
  Close,
} from "@mui/icons-material";
import { useSafeAuth } from "../SafeAuthContext";
import MFASetup from "../components/auth/MFASetup";

const Profile: React.FC = () => {
  console.log("🔴 PROFILE: Emergency auth bypass starting");
  
  // Emergency fallback state
  const [emergencyUser, setEmergencyUser] = useState(null);
  
  // Try normal context first
  let normalContext;
  try {
    normalContext = useSafeAuth();
    console.log("🔴 Normal context works:", normalContext);
  } catch (error) {
    console.error("🔴 Normal context failed:", error);
    normalContext = null;
  }
  
  // Manual user fetch if context fails
  useEffect(() => {
    if (!normalContext && !emergencyUser) {
      console.log("🔴 EMERGENCY: Manual user fetch triggered");
      const token = localStorage.getItem('auth_token');
      if (token) {
        fetch('https://lfa-legacy-go-backend-376491487980.us-central1.run.app/api/auth/me', {
          headers: { 'Authorization': 'Bearer ' + token }
        })
        .then(r => r.json())
        .then(userData => {
          console.log("🔴 EMERGENCY: Manual fetch success:", userData);
          const user = {
            ...userData,
            mfa_enabled: Boolean(userData.mfa_enabled || false)
          };
          setEmergencyUser(user);
        })
        .catch(error => {
          console.error("🔴 EMERGENCY: Manual fetch failed:", error);
        });
      }
    }
  }, [normalContext, emergencyUser]);
  
  // Use whichever works
  const state = normalContext?.state || { user: emergencyUser, loading: false, error: null };
  
  console.log("🔴 FINAL STATE:", state);
  const [showMFASetup, setShowMFASetup] = useState(false);

  if (!state.user) {
    return <Typography>Loading...</Typography>;
  }

  const winRate =
    state.user.games_played > 0
      ? (state.user.games_won / state.user.games_played) * 100
      : 0;

  return (
    <Box sx={{ p: 3 }}>
      <Typography variant="h4" component="h1" gutterBottom fontWeight="bold">
        Profile
      </Typography>

      <Grid container spacing={3} sx={{ mt: 2 }}>
        {/* Personal Information Card */}
        <Grid size={{ xs: 12, md: 6 }}>
          <Card>
            <CardContent>
              <Box sx={{ display: "flex", alignItems: "center", mb: 3 }}>
                <Avatar
                  sx={{
                    width: 64,
                    height: 64,
                    mr: 2,
                    bgcolor: "primary.main",
                    fontSize: "1.5rem",
                  }}
                >
                  {state.user.full_name.charAt(0).toUpperCase()}
                </Avatar>
                <Box sx={{ flexGrow: 1 }}>
                  <Typography variant="h6" gutterBottom>
                    Personal Information
                  </Typography>
                  <Button startIcon={<Edit />} variant="outlined" size="small">
                    Edit Profile
                  </Button>
                </Box>
              </Box>

              <Divider sx={{ mb: 3 }} />

              <Box sx={{ mt: 2 }}>
                <Typography variant="body2" color="text.secondary">
                  Full Name
                </Typography>
                <Typography variant="body1" sx={{ mb: 2 }}>
                  {state.user.full_name}
                </Typography>

                <Typography variant="body2" color="text.secondary">
                  Username
                </Typography>
                <Typography variant="body1" sx={{ mb: 2 }}>
                  @{state.user.username}
                </Typography>

                <Typography variant="body2" color="text.secondary">
                  Email
                </Typography>
                <Typography variant="body1" sx={{ mb: 2 }}>
                  {state.user.email}
                </Typography>

                <Typography variant="body2" color="text.secondary">
                  Account Type
                </Typography>
                <Box sx={{ mt: 1 }}>
                  <Chip
                    icon={<Person />}
                    label={state.user.is_admin ? "Administrator" : "Player"}
                    color={state.user.is_admin ? "secondary" : "primary"}
                    variant="outlined"
                  />
                </Box>
              </Box>
            </CardContent>
          </Card>
        </Grid>

        {/* Statistics Card */}
        <Grid size={{ xs: 12, md: 6 }}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                <EmojiEvents sx={{ mr: 1, verticalAlign: "middle" }} />
                Game Statistics
              </Typography>

              <Grid container spacing={2} sx={{ mt: 2 }}>
                <Grid size={{ xs: 6 }}>
                  <Box
                    textAlign="center"
                    sx={{ p: 2, bgcolor: "primary.light", borderRadius: 1 }}
                  >
                    <Typography variant="h4" color="primary.contrastText">
                      {state.user.games_played || 0}
                    </Typography>
                    <Typography variant="caption" color="primary.contrastText">
                      Games Played
                    </Typography>
                  </Box>
                </Grid>

                <Grid size={{ xs: 6 }}>
                  <Box
                    textAlign="center"
                    sx={{ p: 2, bgcolor: "success.light", borderRadius: 1 }}
                  >
                    <Typography variant="h4" color="success.contrastText">
                      {state.user.games_won || 0}
                    </Typography>
                    <Typography variant="caption" color="success.contrastText">
                      Games Won
                    </Typography>
                  </Box>
                </Grid>
              </Grid>

              <Box sx={{ mt: 3 }}>
                <Box
                  sx={{
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    mb: 1,
                  }}
                >
                  <Typography variant="body2" color="text.secondary">
                    Win Rate
                  </Typography>
                  <Typography variant="body2" fontWeight="bold">
                    {winRate.toFixed(1)}%
                  </Typography>
                </Box>
                <LinearProgress
                  variant="determinate"
                  value={winRate}
                  sx={{
                    height: 8,
                    borderRadius: 4,
                    "& .MuiLinearProgress-bar": {
                      borderRadius: 4,
                      backgroundColor:
                        winRate >= 50 ? "success.main" : "warning.main",
                    },
                  }}
                />
              </Box>

              <Divider sx={{ my: 3 }} />

              <Box
                sx={{
                  display: "flex",
                  justifyContent: "space-between",
                  alignItems: "center",
                }}
              >
                <Typography variant="body2" color="text.secondary">
                  Current Ranking
                </Typography>
                <Chip
                  icon={<TrendingUp />}
                  label={`#${Math.floor(Math.random() * 100) + 1}`}
                  color="warning"
                  variant="outlined"
                />
              </Box>

              <Box
                sx={{
                  display: "flex",
                  justifyContent: "space-between",
                  alignItems: "center",
                  mt: 2,
                }}
              >
                <Typography variant="body2" color="text.secondary">
                  Total Score
                </Typography>
                <Typography variant="h6" color="primary">
                  {(
                    (state.user.games_won || 0) * 10 +
                    (state.user.games_played || 0) * 2
                  ).toLocaleString()}
                </Typography>
              </Box>
            </CardContent>
          </Card>
        </Grid>

        {/* Achievements Card */}
        <Grid size={{ xs: 12, md: 6 }}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                <EmojiEvents sx={{ mr: 1, verticalAlign: "middle" }} />
                Achievements
              </Typography>

              <Box sx={{ display: "flex", flexWrap: "wrap", gap: 1, mt: 2 }}>
                {state.user.games_played >= 1 && (
                  <Chip
                    icon={<SportsScore />}
                    label="First Game"
                    color="success"
                    size="small"
                  />
                )}
                {state.user.games_won >= 1 && (
                  <Chip
                    icon={<EmojiEvents />}
                    label="First Win"
                    color="warning"
                    size="small"
                  />
                )}
                {state.user.games_played >= 10 && (
                  <Chip
                    icon={<SportsScore />}
                    label="Veteran Player"
                    color="primary"
                    size="small"
                  />
                )}
                {winRate >= 70 && (
                  <Chip
                    icon={<TrendingUp />}
                    label="Champion"
                    color="error"
                    size="small"
                  />
                )}
                {state.user.games_played === 0 && (
                  <Typography
                    variant="body2"
                    color="text.secondary"
                    sx={{ fontStyle: "italic" }}
                  >
                    Play your first game to unlock achievements!
                  </Typography>
                )}
              </Box>
            </CardContent>
          </Card>
        </Grid>

        {/* Activity Card */}
        <Grid size={{ xs: 12, md: 6 }}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                Recent Activity
              </Typography>

              <Box sx={{ mt: 2 }}>
                {state.user.games_played > 0 ? (
                  <Box>
                    <Typography variant="body2" color="text.secondary">
                      Last game played: 2 days ago
                    </Typography>
                    <Typography
                      variant="body2"
                      color="text.secondary"
                      sx={{ mt: 1 }}
                    >
                      Best winning streak:{" "}
                      {Math.max(1, Math.floor(state.user.games_won / 2))} games
                    </Typography>
                    <Typography
                      variant="body2"
                      color="text.secondary"
                      sx={{ mt: 1 }}
                    >
                      Member since: {new Date().toLocaleDateString()}
                    </Typography>
                  </Box>
                ) : (
                  <Typography
                    variant="body2"
                    color="text.secondary"
                    sx={{ fontStyle: "italic" }}
                  >
                    No recent activity. Start playing to see your activity here!
                  </Typography>
                )}
              </Box>
            </CardContent>
          </Card>
        </Grid>

        {/* Security Card */}
        <Grid size={{ xs: 12, md: 6 }}>
          <Card>
            <CardContent>
              <Box sx={{ display: "flex", alignItems: "center", mb: 3 }}>
                <Security sx={{ mr: 2, color: "primary.main", fontSize: 28 }} />
                <Box sx={{ flexGrow: 1 }}>
                  <Typography variant="h6" gutterBottom>
                    Account Security
                  </Typography>
                </Box>
              </Box>

              <Divider sx={{ mb: 3 }} />

              {/* Email Verification Status */}
              <Box sx={{ display: "flex", alignItems: "center", mb: 2 }}>
                <Typography variant="body2" color="text.secondary" sx={{ flexGrow: 1 }}>
                  Email Verification
                </Typography>
                <Chip
                  icon={<CheckCircle />}
                  label="Verified"
                  color="success"
                  size="small"
                />
              </Box>

              {/* MFA Status */}
              <Box sx={{ display: "flex", alignItems: "center", mb: 3 }}>
                <Typography variant="body2" color="text.secondary" sx={{ flexGrow: 1 }}>
                  Two-Factor Authentication
                </Typography>
                <Chip
                  label={(state.user as any).mfa_enabled ? "Enabled" : "Disabled"}
                  color={(state.user as any).mfa_enabled ? "success" : "warning"}
                  size="small"
                />
              </Box>

              {/* MFA Setup Button */}
              {!(state.user as any).mfa_enabled && (
                <Button
                  fullWidth
                  variant="outlined"
                  startIcon={<Security />}
                  onClick={() => setShowMFASetup(true)}
                  sx={{
                    borderColor: 'primary.main',
                    '&:hover': {
                      borderColor: 'primary.dark',
                      backgroundColor: 'primary.light'
                    }
                  }}
                >
                  Enable Two-Factor Authentication
                </Button>
              )}
            </CardContent>
          </Card>
        </Grid>
      </Grid>

      {/* MFA Setup Dialog */}
      <Dialog 
        open={showMFASetup} 
        onClose={() => setShowMFASetup(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
          <Typography variant="h6">Setup Two-Factor Authentication</Typography>
          <IconButton onClick={() => setShowMFASetup(false)}>
            <Close />
          </IconButton>
        </DialogTitle>
        <DialogContent sx={{ p: 0 }}>
          <MFASetup 
            onComplete={() => {
              setShowMFASetup(false);
              // Refresh user data to show MFA as enabled
              window.location.reload();
            }}
            onCancel={() => setShowMFASetup(false)}
          />
        </DialogContent>
      </Dialog>
    </Box>
  );
};

export default Profile;


==== Page Component: Social.tsx ==== (frontend/src/pages/Social.tsx)
import React, { useState } from "react";
import {
  Box,
  Typography,
  Tabs,
  Tab,
  IconButton,
  Paper,
  useTheme,
  useMediaQuery,
} from "@mui/material";
import {
  ArrowBack,
  People,
  PersonAdd,
  EmojiEvents,
  Mail,
} from "@mui/icons-material";
import { useNavigate } from "react-router-dom";
import FriendsList from "../components/social/FriendsList";
import UserSearch from "../components/social/UserSearch";
import ChallengeSystem from "../components/social/ChallengeSystem";
import FriendRequests from "../components/social/FriendRequests";

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel({ children, value, index }: TabPanelProps) {
  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`social-tabpanel-${index}`}
      aria-labelledby={`social-tab-${index}`}
    >
      {value === index && <Box sx={{ py: 3 }}>{children}</Box>}
    </div>
  );
}

const Social: React.FC = () => {
  const navigate = useNavigate();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("md"));
  const [activeTab, setActiveTab] = useState(0);

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setActiveTab(newValue);
  };

  const tabs = [
    { label: "My Friends", icon: <People />, component: <FriendsList /> },
    { label: "Find Players", icon: <PersonAdd />, component: <UserSearch /> },
    {
      label: "Challenges",
      icon: <EmojiEvents />,
      component: <ChallengeSystem />,
    },
    { label: "Requests", icon: <Mail />, component: <FriendRequests /> },
  ];

  return (
    <Box sx={{ p: { xs: 2, md: 3 } }}>
      {/* Header */}
      <Box sx={{ display: "flex", alignItems: "center", mb: 4 }}>
        <IconButton
          onClick={() => navigate("/dashboard")}
          sx={{ mr: 2 }}
          aria-label="Back to dashboard"
        >
          <ArrowBack />
        </IconButton>
        <Typography variant="h4" component="h1" fontWeight="bold">
          Social Hub 👥
        </Typography>
      </Box>

      {/* Tabs Navigation */}
      <Paper sx={{ mb: 3 }}>
        <Tabs
          value={activeTab}
          onChange={handleTabChange}
          variant={isMobile ? "scrollable" : "fullWidth"}
          scrollButtons={isMobile ? "auto" : false}
          sx={{
            "& .MuiTab-root": {
              minHeight: 64,
              textTransform: "none",
              fontSize: "1rem",
              fontWeight: 600,
            },
          }}
        >
          {tabs.map((tab, index) => (
            <Tab
              key={index}
              label={isMobile ? undefined : tab.label}
              icon={tab.icon}
              iconPosition={isMobile ? "top" : "start"}
              aria-label={tab.label}
              sx={{
                "& .MuiTab-iconWrapper": {
                  mb: isMobile ? 0.5 : 0,
                  mr: isMobile ? 0 : 1,
                },
              }}
            />
          ))}
        </Tabs>
      </Paper>

      {/* Tab Content */}
      {tabs.map((tab, index) => (
        <TabPanel key={index} value={activeTab} index={index}>
          {tab.component}
        </TabPanel>
      ))}
    </Box>
  );
};

export default Social;


==== Page Component: TournamentDetails.tsx ==== (frontend/src/pages/TournamentDetails.tsx)
import React, { useState, useEffect } from "react";
import {
  Box,
  Typography,
  Card,
  CardContent,
  Grid,
  Chip,
  LinearProgress,
  Alert,
  IconButton,
  Tooltip,
  Tabs,
  Tab,
  Skeleton,
} from "@mui/material";
import {
  ArrowBack,
  Refresh,
  EmojiEvents,
  People,
  Schedule,
  LocationOn,
  AccountTree,
} from "@mui/icons-material";
import { useNavigate, useParams } from "react-router-dom";
import { format } from "date-fns";
import { tournamentService, Tournament } from "../services/api";
import RegistrationPanel from "../components/tournaments/RegistrationPanel";
import ParticipantsList from "../components/tournaments/ParticipantsList";
import TournamentBracket from "../components/tournaments/TournamentBracket";

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel({ children, value, index }: TabPanelProps) {
  return (
    <div hidden={value !== index}>
      {value === index && <Box sx={{ py: 3 }}>{children}</Box>}
    </div>
  );
}

interface TournamentDetailsData {
  tournament: Tournament;
  participants: any[];
  bracket?: any;
  current_round: number;
  total_rounds: number;
  user_participation?: any;
  can_register: boolean;
  can_withdraw: boolean;
  upcoming_matches: any[];
  completed_matches: any[];
  tournament_rules: any;
}

const TournamentDetails: React.FC = () => {
  const navigate = useNavigate();
  const { tournamentId } = useParams<{ tournamentId: string }>();
  const [tournamentDetails, setTournamentDetails] =
    useState<TournamentDetailsData | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState(0);

  const loadTournamentDetails = async () => {
    if (!tournamentId) return;

    setLoading(true);
    setError(null);
    try {
      const details = await tournamentService.getTournament(
        parseInt(tournamentId)
      );
      setTournamentDetails(details);
    } catch (err: any) {
      setError(err.message || "Failed to load tournament details");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadTournamentDetails();
  }, [tournamentId]);

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setActiveTab(newValue);
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case "registration":
        return "success";
      case "in_progress":
        return "warning";
      case "completed":
        return "primary";
      case "cancelled":
        return "error";
      default:
        return "default";
    }
  };

  const getStatusText = (status: string) => {
    switch (status) {
      case "registration":
        return "Registration Open";
      case "in_progress":
        return "In Progress";
      case "completed":
        return "Completed";
      case "cancelled":
        return "Cancelled";
      default:
        return status;
    }
  };

  if (loading && !tournamentDetails) {
    return (
      <Box sx={{ p: { xs: 2, md: 3 } }}>
        {/* Header Skeleton */}
        <Box sx={{ display: "flex", alignItems: "center", mb: 4 }}>
          <IconButton onClick={() => navigate("/tournaments")} sx={{ mr: 2 }}>
            <ArrowBack />
          </IconButton>
          <Skeleton variant="text" width={300} height={48} />
        </Box>

        {/* Content Skeleton */}
        <Grid container spacing={3}>
          <Grid size={{ xs: 12, md: 8 }}>
            <Skeleton variant="rectangular" height={200} sx={{ mb: 3 }} />
            <Skeleton variant="rectangular" height={300} />
          </Grid>
          <Grid size={{ xs: 12, md: 4 }}>
            <Skeleton variant="rectangular" height={400} />
          </Grid>
        </Grid>
      </Box>
    );
  }

  if (error) {
    return (
      <Box sx={{ p: { xs: 2, md: 3 } }}>
        <Box sx={{ display: "flex", alignItems: "center", mb: 4 }}>
          <IconButton onClick={() => navigate("/tournaments")} sx={{ mr: 2 }}>
            <ArrowBack />
          </IconButton>
          <Typography variant="h4" component="h1" fontWeight="bold">
            Tournament Details
          </Typography>
        </Box>
        <Alert
          severity="error"
          action={
            <IconButton onClick={loadTournamentDetails}>
              <Refresh />
            </IconButton>
          }
        >
          {error}
        </Alert>
      </Box>
    );
  }

  if (!tournamentDetails) {
    return (
      <Box sx={{ p: { xs: 2, md: 3 } }}>
        <Box sx={{ display: "flex", alignItems: "center", mb: 4 }}>
          <IconButton onClick={() => navigate("/tournaments")} sx={{ mr: 2 }}>
            <ArrowBack />
          </IconButton>
          <Typography variant="h4" component="h1" fontWeight="bold">
            Tournament Not Found
          </Typography>
        </Box>
        <Alert severity="info">Tournament details could not be loaded.</Alert>
      </Box>
    );
  }

  const { tournament } = tournamentDetails;

  return (
    <Box sx={{ p: { xs: 2, md: 3 } }}>
      {/* Header */}
      <Box sx={{ display: "flex", alignItems: "center", mb: 4 }}>
        <IconButton onClick={() => navigate("/tournaments")} sx={{ mr: 2 }}>
          <ArrowBack />
        </IconButton>
        <Box sx={{ flex: 1 }}>
          <Typography
            variant="h4"
            component="h1"
            fontWeight="bold"
            gutterBottom
          >
            {tournament.name}
          </Typography>
          <Box sx={{ display: "flex", gap: 1, flexWrap: "wrap" }}>
            <Chip
              label={getStatusText(tournament.status)}
              color={getStatusColor(tournament.status)}
              icon={<EmojiEvents />}
            />
            <Chip
              label={`${tournament.current_participants}/${tournament.max_participants} players`}
              color={tournament.is_full ? "error" : "primary"}
              variant="outlined"
              icon={<People />}
            />
          </Box>
        </Box>
        <Tooltip title="Refresh">
          <IconButton onClick={loadTournamentDetails} disabled={loading}>
            <Refresh />
          </IconButton>
        </Tooltip>
      </Box>

      {loading && <LinearProgress sx={{ mb: 3 }} />}

      {/* Tournament Info Card */}
      <Card sx={{ mb: 3 }}>
        <CardContent>
          <Grid container spacing={3}>
            <Grid size={{ xs: 12, md: 8 }}>
              <Typography variant="h6" gutterBottom>
                Tournament Information
              </Typography>
              <Typography variant="body1" paragraph>
                {tournament.description}
              </Typography>

              <Grid container spacing={2}>
                <Grid size={{ xs: 12, sm: 6 }}>
                  <Box sx={{ display: "flex", alignItems: "center", mb: 1 }}>
                    <Schedule sx={{ mr: 1, color: "text.secondary" }} />
                    <Typography variant="body2" color="text.secondary">
                      Start:{" "}
                      {format(
                        new Date(tournament.start_time),
                        "MMM dd, yyyy HH:mm"
                      )}
                    </Typography>
                  </Box>
                  <Box sx={{ display: "flex", alignItems: "center", mb: 1 }}>
                    <Schedule sx={{ mr: 1, color: "text.secondary" }} />
                    <Typography variant="body2" color="text.secondary">
                      End:{" "}
                      {format(
                        new Date(tournament.end_time),
                        "MMM dd, yyyy HH:mm"
                      )}
                    </Typography>
                  </Box>
                </Grid>
                <Grid size={{ xs: 12, sm: 6 }}>
                  <Box sx={{ display: "flex", alignItems: "center", mb: 1 }}>
                    <LocationOn sx={{ mr: 1, color: "text.secondary" }} />
                    <Typography variant="body2" color="text.secondary">
                      {tournament.location_name}
                    </Typography>
                  </Box>
                  <Box sx={{ display: "flex", alignItems: "center", mb: 1 }}>
                    <EmojiEvents sx={{ mr: 1, color: "text.secondary" }} />
                    <Typography variant="body2" color="text.secondary">
                      Entry: {tournament.entry_fee_credits} credits
                    </Typography>
                  </Box>
                </Grid>
              </Grid>
            </Grid>

            <Grid size={{ xs: 12, md: 4 }}>
              <RegistrationPanel
                tournament={tournament}
                canRegister={tournamentDetails.can_register}
                canWithdraw={tournamentDetails.can_withdraw}
                userParticipation={tournamentDetails.user_participation}
                onRegistrationChange={loadTournamentDetails}
              />
            </Grid>
          </Grid>
        </CardContent>
      </Card>

      {/* Tabs */}
      <Box sx={{ borderBottom: 1, borderColor: "divider", mb: 3 }}>
        <Tabs value={activeTab} onChange={handleTabChange}>
          <Tab
            label={`Participants (${tournament.current_participants})`}
            icon={<People />}
            iconPosition="start"
          />
          {tournament.status === "in_progress" && (
            <Tab label="Bracket" icon={<AccountTree />} iconPosition="start" />
          )}
          <Tab
            label="Rules & Format"
            icon={<Schedule />}
            iconPosition="start"
          />
        </Tabs>
      </Box>

      {/* Tab Content */}
      <TabPanel value={activeTab} index={0}>
        <ParticipantsList
          participants={tournamentDetails.participants}
          tournamentId={parseInt(tournamentId || "0")}
        />
      </TabPanel>

      {tournament.status === "in_progress" && (
        <TabPanel value={activeTab} index={1}>
          <TournamentBracket
            tournamentId={parseInt(tournamentId || "0")}
            bracket={tournamentDetails.bracket}
            currentRound={tournamentDetails.current_round}
            totalRounds={tournamentDetails.total_rounds}
          />
        </TabPanel>
      )}

      <TabPanel
        value={activeTab}
        index={tournament.status === "in_progress" ? 2 : 1}
      >
        <Card>
          <CardContent>
            <Typography variant="h6" gutterBottom>
              Tournament Rules & Format
            </Typography>
            <Grid container spacing={2}>
              <Grid size={{ xs: 12, md: 6 }}>
                <Typography variant="subtitle2" gutterBottom>
                  Format Details
                </Typography>
                <Typography variant="body2" paragraph>
                  Type: {tournament.tournament_type}
                </Typography>
                <Typography variant="body2" paragraph>
                  Game: {tournament.game_type}
                </Typography>
                <Typography variant="body2" paragraph>
                  Format: {tournament.format}
                </Typography>
                <Typography variant="body2" paragraph>
                  Level Range: {tournament.min_level} -{" "}
                  {tournament.max_level || "No limit"}
                </Typography>
              </Grid>
              <Grid size={{ xs: 12, md: 6 }}>
                <Typography variant="subtitle2" gutterBottom>
                  Prize Information
                </Typography>
                <Typography variant="body2" paragraph>
                  Prize Pool: {tournament.prize_pool_credits} credits
                </Typography>
                <Typography variant="body2" paragraph>
                  Registration Deadline:{" "}
                  {format(
                    new Date(tournament.registration_deadline),
                    "MMM dd, yyyy HH:mm"
                  )}
                </Typography>
                <Typography variant="body2" paragraph>
                  Organizer: {tournament.organizer_username}
                </Typography>
              </Grid>
            </Grid>
          </CardContent>
        </Card>
      </TabPanel>
    </Box>
  );
};

export default TournamentDetails;


==== Page Component: Tournaments.tsx ==== (frontend/src/pages/Tournaments.tsx)
import React, { useState, useEffect } from "react";
import {
  Box,
  Typography,
  Grid,
  Card,
  CardContent,
  Button,
  Chip,
  CircularProgress,
  Alert,
  IconButton,
  Avatar,
  Divider,
} from "@mui/material";
import {
  EmojiEvents,
  LocationOn,
  Schedule,
  People,
  AccountBalanceWallet,
  Refresh,
  Add,
  StarBorder,
  Star,
} from "@mui/icons-material";
import { useSafeAuth } from "../SafeAuthContext";
import { tournamentService } from "../services/api";

interface Tournament {
  id: number;
  name: string;
  description: string;
  status: string;
  start_time: string;
  entry_fee_credits: number;
  current_participants: number;
  max_participants: number;
  location_name: string;
  organizer_username?: string;
  prize_pool_credits?: number;
  tournament_type?: string;
}

const Tournaments: React.FC = () => {
  const { state } = useSafeAuth();
  const [tournaments, setTournaments] = useState<Tournament[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [refreshing, setRefreshing] = useState(false);
  const [favorites, setFavorites] = useState<number[]>([]);

  const loadTournaments = async () => {
    try {
      const data = await tournamentService.getTournaments();
      setTournaments(data);
      setError(null);
    } catch (err: any) {
      setError(err.message || "Failed to load tournaments");
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  useEffect(() => {
    loadTournaments();
  }, []);

  const handleRefresh = async () => {
    setRefreshing(true);
    await loadTournaments();
  };

  const handleRegister = async (tournamentId: number) => {
    try {
      await tournamentService.registerForTournament(tournamentId);
      await loadTournaments(); // Refresh data after registration
    } catch (err: any) {
      alert(err.message || "Registration failed");
    }
  };

  const toggleFavorite = (tournamentId: number) => {
    setFavorites((prev) =>
      prev.includes(tournamentId)
        ? prev.filter((id) => id !== tournamentId)
        : [...prev, tournamentId]
    );
  };

  const getStatusColor = (status: string) => {
    switch (status?.toLowerCase()) {
      case "open":
      case "registration_open":
        return "success";
      case "in_progress":
      case "active":
        return "warning";
      case "completed":
        return "default";
      case "cancelled":
        return "error";
      default:
        return "default";
    }
  };

  const formatDateTime = (dateString: string) => {
    const date = new Date(dateString);
    return {
      date: date.toLocaleDateString(),
      time: date.toLocaleTimeString("en-US", {
        hour: "2-digit",
        minute: "2-digit",
        hour12: false,
      }),
    };
  };

  if (loading) {
    return (
      <Box
        sx={{
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          py: 8,
        }}
      >
        <Box sx={{ textAlign: "center" }}>
          <CircularProgress size={60} />
          <Typography variant="h6" sx={{ mt: 2 }}>
            Loading tournaments...
          </Typography>
        </Box>
      </Box>
    );
  }

  if (error) {
    return (
      <Box sx={{ p: 3 }}>
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
        <Button
          variant="contained"
          onClick={handleRefresh}
          startIcon={<Refresh />}
        >
          Try Again
        </Button>
      </Box>
    );
  }

  return (
    <Box sx={{ p: 3 }}>
      <Box
        sx={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          mb: 4,
        }}
      >
        <Typography variant="h4" component="h1" fontWeight="bold">
          🏆 Tournaments
        </Typography>
        <Box sx={{ display: "flex", gap: 2 }}>
          <Button
            variant="outlined"
            startIcon={<Refresh />}
            onClick={handleRefresh}
            disabled={refreshing}
          >
            {refreshing ? "Refreshing..." : "Refresh"}
          </Button>
          <Button
            variant="contained"
            startIcon={<Add />}
            onClick={() => alert("Create tournament feature coming soon!")}
          >
            Create Tournament
          </Button>
        </Box>
      </Box>

      {tournaments.length === 0 ? (
        <Box sx={{ textAlign: "center", py: 8 }}>
          <EmojiEvents sx={{ fontSize: 80, color: "text.secondary", mb: 2 }} />
          <Typography variant="h6" color="text.secondary" sx={{ mb: 1 }}>
            No tournaments available
          </Typography>
          <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
            Check back later or create your own tournament to get started!
          </Typography>
          <Button
            variant="contained"
            startIcon={<Add />}
            onClick={() => alert("Create tournament feature coming soon!")}
          >
            Create Your First Tournament
          </Button>
        </Box>
      ) : (
        <Grid container spacing={3}>
          {tournaments.map((tournament) => {
            const { date, time } = formatDateTime(tournament.start_time);
            const isFavorite = favorites.includes(tournament.id);
            const isFull =
              tournament.current_participants >= tournament.max_participants;
            const isRegistrationOpen =
              tournament.status?.toLowerCase() === "open" ||
              tournament.status?.toLowerCase() === "registration_open";

            return (
              <Grid size={{ xs: 12, sm: 6, lg: 4 }} key={tournament.id}>
                <Card
                  sx={{
                    height: "100%",
                    display: "flex",
                    flexDirection: "column",
                    position: "relative",
                    "&:hover": {
                      boxShadow: 4,
                      transform: "translateY(-2px)",
                      transition: "all 0.2s ease-in-out",
                    },
                  }}
                >
                  {/* Favorite toggle */}
                  <IconButton
                    size="small"
                    onClick={() => toggleFavorite(tournament.id)}
                    sx={{
                      position: "absolute",
                      top: 8,
                      right: 8,
                      zIndex: 1,
                      bgcolor: "background.paper",
                      "&:hover": { bgcolor: "background.paper" },
                    }}
                  >
                    {isFavorite ? <Star color="warning" /> : <StarBorder />}
                  </IconButton>

                  <CardContent sx={{ flexGrow: 1, p: 3 }}>
                    {/* Tournament Header */}
                    <Box sx={{ mb: 2 }}>
                      <Typography variant="h6" component="h3" gutterBottom>
                        {tournament.name}
                      </Typography>
                      <Chip
                        label={tournament.status || "Open"}
                        color={getStatusColor(tournament.status)}
                        size="small"
                        sx={{ mb: 1 }}
                      />
                    </Box>

                    {/* Tournament Description */}
                    <Typography
                      variant="body2"
                      color="text.secondary"
                      sx={{ mb: 2, minHeight: "40px" }}
                    >
                      {tournament.description ||
                        "Join this exciting tournament and compete with other players!"}
                    </Typography>

                    <Divider sx={{ mb: 2 }} />

                    {/* Tournament Details */}
                    <Box
                      sx={{
                        display: "flex",
                        flexDirection: "column",
                        gap: 1.5,
                        mb: 3,
                      }}
                    >
                      <Box
                        sx={{ display: "flex", alignItems: "center", gap: 1 }}
                      >
                        <Schedule color="action" fontSize="small" />
                        <Typography variant="body2">
                          {date} at {time}
                        </Typography>
                      </Box>

                      <Box
                        sx={{ display: "flex", alignItems: "center", gap: 1 }}
                      >
                        <LocationOn color="action" fontSize="small" />
                        <Typography variant="body2">
                          {tournament.location_name || "TBD"}
                        </Typography>
                      </Box>

                      <Box
                        sx={{ display: "flex", alignItems: "center", gap: 1 }}
                      >
                        <People color="action" fontSize="small" />
                        <Typography variant="body2">
                          {tournament.current_participants}/
                          {tournament.max_participants} players
                        </Typography>
                        {isFull && (
                          <Chip label="Full" size="small" color="error" />
                        )}
                      </Box>

                      <Box
                        sx={{ display: "flex", alignItems: "center", gap: 1 }}
                      >
                        <AccountBalanceWallet color="action" fontSize="small" />
                        <Typography variant="body2">
                          {tournament.entry_fee_credits} credits
                        </Typography>
                        {tournament.prize_pool_credits && (
                          <Chip
                            label={`Prize: ${tournament.prize_pool_credits}`}
                            size="small"
                            color="success"
                          />
                        )}
                      </Box>
                    </Box>

                    {/* Tournament Type & Organizer */}
                    <Box
                      sx={{
                        display: "flex",
                        justifyContent: "space-between",
                        alignItems: "center",
                        mb: 3,
                      }}
                    >
                      {tournament.tournament_type && (
                        <Chip
                          label={tournament.tournament_type}
                          variant="outlined"
                          size="small"
                        />
                      )}
                      {tournament.organizer_username && (
                        <Box
                          sx={{
                            display: "flex",
                            alignItems: "center",
                            gap: 0.5,
                          }}
                        >
                          <Avatar
                            sx={{ width: 20, height: 20, fontSize: "0.75rem" }}
                          >
                            {tournament.organizer_username
                              .charAt(0)
                              .toUpperCase()}
                          </Avatar>
                          <Typography variant="caption" color="text.secondary">
                            by {tournament.organizer_username}
                          </Typography>
                        </Box>
                      )}
                    </Box>
                  </CardContent>

                  {/* Action Button */}
                  <Box sx={{ p: 3, pt: 0 }}>
                    <Button
                      variant="contained"
                      fullWidth
                      size="large"
                      onClick={() => handleRegister(tournament.id)}
                      disabled={!isRegistrationOpen || isFull}
                      startIcon={<EmojiEvents />}
                      sx={{
                        py: 1.5,
                        fontWeight: "bold",
                      }}
                    >
                      {!isRegistrationOpen
                        ? "Registration Closed"
                        : isFull
                          ? "Tournament Full"
                          : "Register Now"}
                    </Button>
                  </Box>
                </Card>
              </Grid>
            );
          })}
        </Grid>
      )}

      {/* Summary Stats */}
      {tournaments.length > 0 && (
        <Box
          sx={{ mt: 6, p: 3, bgcolor: "background.default", borderRadius: 2 }}
        >
          <Typography variant="h6" gutterBottom>
            Tournament Summary
          </Typography>
          <Grid container spacing={3}>
            <Grid size={{ xs: 6, sm: 3 }}>
              <Box textAlign="center">
                <Typography variant="h4" color="primary">
                  {tournaments.length}
                </Typography>
                <Typography variant="caption">Total Tournaments</Typography>
              </Box>
            </Grid>
            <Grid size={{ xs: 6, sm: 3 }}>
              <Box textAlign="center">
                <Typography variant="h4" color="success.main">
                  {
                    tournaments.filter(
                      (t) =>
                        t.status?.toLowerCase() === "open" ||
                        t.status?.toLowerCase() === "registration_open"
                    ).length
                  }
                </Typography>
                <Typography variant="caption">Open for Registration</Typography>
              </Box>
            </Grid>
            <Grid size={{ xs: 6, sm: 3 }}>
              <Box textAlign="center">
                <Typography variant="h4" color="warning.main">
                  {
                    tournaments.filter(
                      (t) =>
                        t.status?.toLowerCase() === "in_progress" ||
                        t.status?.toLowerCase() === "active"
                    ).length
                  }
                </Typography>
                <Typography variant="caption">Active Now</Typography>
              </Box>
            </Grid>
            <Grid size={{ xs: 6, sm: 3 }}>
              <Box textAlign="center">
                <Typography variant="h4" color="text.secondary">
                  {tournaments
                    .reduce((sum, t) => sum + (t.prize_pool_credits || 0), 0)
                    .toLocaleString()}
                </Typography>
                <Typography variant="caption">Total Prize Pool</Typography>
              </Box>
            </Grid>
          </Grid>
        </Box>
      )}
    </Box>
  );
};

export default Tournaments;


==== Frontend Service: api.ts ==== (frontend/src/services/api.ts)
// === frontend/src/services/api.ts ===
// TELJES JAVÍTOTT API SZOLGÁLTATÁS - 422 HIBA MEGOLDÁS

import config from "../config/environment.js";

const API_BASE_URL = config.API_URL;

export class ApiService {
  private baseURL: string;

  constructor(baseURL: string = API_BASE_URL) {
    this.baseURL = baseURL;
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.baseURL}${endpoint}`;

    const config: RequestInit = {
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
      ...options,
    };

    // Add auth token if available
    const token = localStorage.getItem("auth_token");
    if (token) {
      config.headers = {
        ...config.headers,
        Authorization: `Bearer ${token}`,
      };
    }

    try {
      const response = await fetch(url, config);

      if (!response.ok) {
        const errorData = await response.text();
        let errorMessage = `HTTP ${response.status}`;

        try {
          const errorJson = JSON.parse(errorData);
          errorMessage = errorJson.detail || errorJson.message || errorMessage;
        } catch {
          errorMessage = errorData || errorMessage;
        }

        throw new Error(errorMessage);
      }

      // Handle empty responses
      if (response.status === 204) {
        return {} as T;
      }

      return await response.json();
    } catch (error) {
      console.error(`API request failed: ${endpoint}`, error);
      throw error;
    }
  }

  async get<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: "GET" });
  }

  async post<T>(endpoint: string, data?: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: "POST",
      body: data ? JSON.stringify(data) : undefined,
    });
  }

  async put<T>(endpoint: string, data?: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: "PUT",
      body: data ? JSON.stringify(data) : undefined,
    });
  }

  async delete<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: "DELETE" });
  }
}

// === AUTHENTICATION INTERFACES ===

export interface LoginRequest {
  username: string;
  password: string;
}

// ✅ JAVÍTOTT: full_name hozzáadva
export interface RegisterRequest {
  username: string;
  password: string;
  email: string;
  full_name: string; // ✅ KÖTELEZŐ MEZŐ - backend kompatibilitás
  name?: string; // Optional backward compatibility
}

export interface User {
  id: number;
  username: string;
  email: string;
  full_name: string; // ✅ JAVÍTOTT: full_name használata
  display_name?: string;
  level: number;
  xp: number;
  credits: number;
  bio?: string;
  skills: Record<string, number>;
  games_played: number;
  games_won: number;
  games_lost?: number;
  friend_count: number;
  challenge_wins?: number;
  challenge_losses?: number;
  total_achievements: number;
  is_premium: boolean;
  premium_expires_at?: string;
  user_type: string;
  is_active: boolean;
  is_admin?: boolean;
  mfa_enabled?: boolean;
  created_at: string;
  last_login?: string;
  last_activity?: string;
}

export interface AuthResponse {
  access_token: string;
  token_type: string;
  expires_in: number;
  user: User;
}

export class AuthService extends ApiService {
  async login(credentials: LoginRequest): Promise<AuthResponse> {
    return this.post("/api/auth/login", credentials);
  }

  async register(userData: RegisterRequest): Promise<AuthResponse> {
    // ✅ JAVÍTOTT: Full validation
    if (!userData.full_name || userData.full_name.trim().length === 0) {
      throw new Error("Full name is required");
    }

    // ✅ JAVÍTOTT: Ensure full_name is sent
    const payload = {
      username: userData.username,
      password: userData.password,
      email: userData.email,
      full_name: userData.full_name.trim(),
      name: userData.name || userData.full_name, // Backward compatibility
    };

    return this.post("/api/auth/register", payload);
  }

  async getCurrentUser(): Promise<User> {
    try {
      return await this.get("/api/auth/me");
    } catch (error) {
      // ✅ CRITICAL FIX: Clear invalid token on auth failure
      if (
        error instanceof Error &&
        (error.message.includes("401") ||
          error.message.includes("403") ||
          error.message.includes("Unauthorized"))
      ) {
        console.warn("🔑 Clearing invalid auth token");
        localStorage.removeItem("auth_token");
      }
      throw error;
    }
  }

  async refreshToken(): Promise<AuthResponse> {
    return this.post("/api/auth/refresh");
  }

  async logout(): Promise<void> {
    return this.post("/api/auth/logout");
  }
}

// === TOURNAMENT INTERFACES ===

export interface Tournament {
  id: number;
  tournament_id: string;
  name: string;
  description?: string;
  tournament_type: string;
  game_type: string;
  format: string;
  status: string;
  location_id: number;
  location_name: string;
  start_time: string;
  end_time: string;
  registration_deadline: string;
  min_participants: number;
  max_participants: number;
  current_participants: number;
  entry_fee_credits: number;
  prize_pool_credits: number;
  min_level: number;
  max_level?: number;
  organizer_id: number;
  organizer_username: string;
  winner_id?: number;
  winner_username?: string;
  is_registration_open: boolean;
  is_full: boolean;
  can_start: boolean;
  created_at: string;
}

export interface TournamentDetails {
  tournament: Tournament;
  participants: any[];
  bracket?: any;
  current_round: number;
  total_rounds: number;
  user_participation?: any;
  can_register: boolean;
  can_withdraw: boolean;
  upcoming_matches: any[];
  completed_matches: any[];
  tournament_rules: any;
}

export interface CreateTournamentRequest {
  name: string;
  description?: string;
  tournament_type: string;
  game_type: string;
  format: string;
  location_id: number;
  start_time: string;
  end_time: string;
  registration_deadline: string;
  min_participants: number;
  max_participants: number;
  entry_fee_credits: number;
  prize_distribution: Record<string, number>;
  min_level: number;
  max_level?: number;
  rules?: Record<string, any>;
}

export class TournamentService extends ApiService {
  async getTournaments(): Promise<Tournament[]> {
    return this.get("/api/tournaments");
  }

  async getTournament(id: number): Promise<TournamentDetails> {
    return this.get(`/api/tournaments/${id}`);
  }

  async createTournament(data: CreateTournamentRequest): Promise<Tournament> {
    return this.post("/api/tournaments", data);
  }

  async registerForTournament(tournamentId: number): Promise<void> {
    return this.post(`/api/tournaments/${tournamentId}/register`);
  }

  async withdrawFromTournament(tournamentId: number): Promise<void> {
    return this.delete(`/api/tournaments/${tournamentId}/register`);
  }
}

// === CREDIT INTERFACES ===

export interface CreditPackage {
  id: string;
  name: string;
  credits: number;
  bonus_credits: number;
  price_huf: number;
  price_usd: number;
  discount_percentage?: number;
  popular: boolean;
  description: string;
}

export interface CreditTransaction {
  id: string;
  transaction_id: string;
  user_id: number;
  package_id: string;
  credits_purchased: number;
  bonus_credits: number;
  total_credits: number;
  price_paid: number;
  currency: string;
  payment_method: string;
  status: string;
  created_at: string;
  stripe_payment_intent_id?: string;
}

export interface PurchaseRequest {
  package_id: string;
  payment_method: string;
}

// === COUPON INTERFACES ===

export interface Coupon {
  id: number;
  code: string;
  name: string;
  description: string;
  coupon_type: "fixed" | "percentage";
  credits_reward: number;
  discount_percentage?: number;
  is_active: boolean;
  expires_at?: string;
  max_uses?: number;
  current_uses: number;
  per_user_limit: number;
  created_at: string;
}

export interface CouponRedemptionRequest {
  coupon_code: string;
}

export interface CouponRedemptionResponse {
  success: boolean;
  message: string;
  credits_awarded: number;
  new_balance: number;
  coupon_name: string;
  coupon_description: string;
}

export interface CouponUsage {
  id: number;
  coupon_id: number;
  user_id: number;
  credits_awarded: number;
  ip_address: string;
  user_agent: string;
  redeemed_at: string;
  coupon: {
    code: string;
    name: string;
    description: string;
  };
}

export class CreditService extends ApiService {
  async getPackages(): Promise<CreditPackage[]> {
    return this.get("/api/credits/packages");
  }

  async getCurrentBalance(): Promise<{ credits: number }> {
    return this.get("/api/credits/balance");
  }

  async getTransactionHistory(): Promise<CreditTransaction[]> {
    return this.get("/api/credits/history");
  }

  async purchaseCredits(data: PurchaseRequest): Promise<CreditTransaction> {
    return this.post("/api/credits/purchase", data);
  }

  // === COUPON METHODS ===

  async redeemCoupon(couponCode: string): Promise<CouponRedemptionResponse> {
    return this.post("/api/credits/redeem-coupon", { coupon_code: couponCode });
  }

  async getAvailableCoupons(): Promise<Coupon[]> {
    try {
      // Use the primary user endpoint
      return await this.get("/api/credits/coupons/available");
    } catch (error) {
      console.error("Failed to fetch available coupons:", error);
      throw error;
    }
  }

  async getCouponUsageHistory(): Promise<CouponUsage[]> {
    return this.get("/api/credits/coupons/my-usage");
  }

  async validateCoupon(
    couponCode: string
  ): Promise<{ valid: boolean; message: string; coupon?: Coupon }> {
    try {
      const response = await this.get(
        `/api/credits/validate-coupon?code=${encodeURIComponent(couponCode)}`
      );
      return response;
    } catch (error) {
      return {
        valid: false,
        message: error instanceof Error ? error.message : "Validation failed",
      };
    }
  }

  // Admin-specific coupon methods
  async getAdminCoupons(): Promise<Coupon[]> {
    try {
      return await this.get("/api/credits/admin/coupons");
    } catch (error) {
      console.error("Failed to fetch admin coupons:", error);
      throw error;
    }
  }
}

// === SOCIAL INTERFACES ===

export interface FriendRequest {
  id: number;
  from_user_id: number;
  to_user_id: number;
  from_user: {
    username: string;
    full_name: string;
    level: number;
  };
  to_user: {
    username: string;
    full_name: string;
    level: number;
  };
  status: string;
  created_at: string;
}

export interface Friend {
  user_id: number;
  username: string;
  full_name: string;
  level: number;
  is_online: boolean;
  last_active: string;
  games_played: number;
  win_rate: number;
}

export interface Challenge {
  id: number;
  challenger_id: number;
  challenged_id: number;
  game_type: string;
  location_id?: number;
  status: string;
  created_at: string;
  expires_at: string;
  challenger: {
    username: string;
    full_name: string;
    level: number;
  };
  challenged: {
    username: string;
    full_name: string;
    level: number;
  };
}

export class SocialService extends ApiService {
  async searchUsers(query: string): Promise<User[]> {
    return this.get(`/api/social/search-users?q=${encodeURIComponent(query)}`);
  }

  async sendFriendRequest(userId: number): Promise<void> {
    return this.post(`/api/social/friend-request/${userId}`);
  }

  async respondToFriendRequest(
    requestId: number,
    accept: boolean
  ): Promise<void> {
    return this.post(`/api/social/friend-request/${requestId}/respond`, {
      accept,
    });
  }

  async getFriendRequests(): Promise<FriendRequest[]> {
    console.log('🔍 Fetching INCOMING friend requests...');
    return this.get("/api/social/friend-requests");
  }

  async getSentFriendRequests(): Promise<FriendRequest[]> {
    console.log('🔍 Fetching SENT friend requests...');
    return this.get("/api/social/friend-requests/sent");
  }

  async getFriends(): Promise<Friend[]> {
    return this.get("/api/social/friends");
  }

  async removeFriend(userId: number): Promise<void> {
    return this.delete(`/api/social/friends/${userId}`);
  }

  async sendChallenge(
    userId: number,
    gameType: string,
    locationId?: number
  ): Promise<Challenge> {
    return this.post("/api/social/challenge", {
      challenged_user_id: userId,
      game_type: gameType,
      location_id: locationId,
    });
  }

  async respondToChallenge(
    challengeId: number,
    accept: boolean
  ): Promise<void> {
    return this.post(`/api/social/challenge/${challengeId}/respond`, {
      accept,
    });
  }

  async getChallenges(): Promise<Challenge[]> {
    return this.get("/api/social/challenges");
  }
}

// === LOCATION INTERFACES ===

export interface Location {
  id: number;
  name: string;
  address: string;
  city?: string; // ✅ HOZZÁADVA
  capacity: number;
  price_per_hour: number;
  rating: number;
  amenities: string[];
  available_slots: string[];
  image_url?: string;
  latitude?: number;
  longitude?: number;
}

export class LocationService extends ApiService {
  async getLocations(): Promise<Location[]> {
    return this.get("/api/locations");
  }

  async getLocation(id: number): Promise<Location> {
    return this.get(`/api/locations/${id}`);
  }

  async checkAvailability(locationId: number, date: string): Promise<any> {
    return this.get(
      `/api/booking/availability?location_id=${locationId}&date=${date}`
    );
  }
}

// === EXPORT SERVICES ===

export const authService = new AuthService();
export const tournamentService = new TournamentService();
export const creditService = new CreditService();
export const socialService = new SocialService();
export const locationService = new LocationService();

// ✅ TYPE ALIASES for backward compatibility
export type RegisterData = RegisterRequest;
export type LoginData = LoginRequest;


==== Frontend Service: ChatService.ts ==== (frontend/src/services/ChatService.ts)
// === ChatService.ts - WebSocket Real-time Chat Service ===
import { io } from 'socket.io-client';
import type { Socket } from 'socket.io-client';
import config from '../config/environment';

interface ChatMessage {
  id?: string;
  message: string;
  username: string;
  user_id: string;
  room: string;
  timestamp: string;
}

interface ChatUser {
  id: string;
  username: string;
}

interface AuthenticateData {
  token: string;
  user_id: string;
}

class ChatService {
  private socket: Socket | null = null;
  private isConnected: boolean = false;
  private currentUser: ChatUser | null = null;
  private eventListeners: Record<string, Function[]> = {};

  constructor() {
    this.socket = null;
    this.isConnected = false;
    this.currentUser = null;
    this.eventListeners = {};
  }

  connect(token: string, userId: string, username?: string): Socket {
    // Socket.IO uses HTTP protocol, not WebSocket protocol directly
    const apiUrl = config.API_URL;
    
    console.log('🔌 Connecting to Socket.IO server:', apiUrl);
    console.log('👤 User data:', { userId, username });

    this.socket = io(apiUrl, {
      transports: ['websocket', 'polling'],
      timeout: 10000,
      forceNew: true,
      autoConnect: true,
      reconnection: true,
      reconnectionAttempts: 3,
      reconnectionDelay: 1000,
      auth: {
        token: token,
        user_id: userId,
        username: username
      }
    });

    this.setupEventListeners();
    
    // Enhanced authentication with user data
    this.socket.on('connect', () => {
      console.log('✅ Connected to chat server');
      this.authenticate(token, userId, username);
    });

    this.socket.on('connect_error', (error) => {
      console.error('❌ WebSocket connection failed:', error);
      this.triggerEvent('connection_error', error);
    });

    this.socket.on('disconnect', (reason) => {
      console.warn('⚠️ WebSocket disconnected:', reason);
      this.isConnected = false;
      this.triggerEvent('disconnected', reason);
    });

    return this.socket;
  }

  private authenticate(token: string, userId: string, username?: string): void {
    if (!this.socket) return;
    
    console.log('🔐 Authenticating user:', userId, username);
    
    this.socket.emit('authenticate', {
      token: token,
      user_id: userId,
      username: username
    });
  }

  private setupEventListeners(): void {
    if (!this.socket) return;

    this.socket.on('authenticated', (data: ChatUser) => {
      console.log('✅ Chat authenticated:', data);
      this.isConnected = true;
      this.currentUser = data;
      this.triggerEvent('authenticated', data);
    });

    this.socket.on('authentication_failed', (error: any) => {
      console.error('❌ Authentication failed:', error);
      this.triggerEvent('authentication_failed', error);
    });

    this.socket.on('new_message', (message: ChatMessage) => {
      console.log('💬 New message received:', message);
      this.triggerEvent('message', message);
    });

    this.socket.on('user_joined', (data: any) => {
      console.log('👤 User joined:', data);
      this.triggerEvent('user_joined', data);
    });

    this.socket.on('user_left', (data: any) => {
      console.log('👋 User left:', data);
      this.triggerEvent('user_left', data);
    });

    this.socket.on('room_joined', (data: any) => {
      console.log('🏠 Joined room:', data);
      this.triggerEvent('room_joined', data);
    });

    this.socket.on('error', (error: any) => {
      console.error('❌ Chat error:', error);
      this.triggerEvent('error', error);
    });

    // Server status events
    this.socket.on('server_message', (data: any) => {
      console.log('📢 Server message:', data);
      this.triggerEvent('server_message', data);
    });
  }

  sendMessage(message: string, room: string = 'global_chat'): void {
    if (!this.socket || !this.isConnected) {
      console.warn('⚠️ Cannot send message: not connected');
      this.triggerEvent('error', { message: 'Not connected to chat server' });
      return;
    }

    if (!message.trim()) {
      console.warn('⚠️ Cannot send empty message');
      return;
    }

    console.log('📤 Sending message:', { message, room });
    this.socket.emit('send_message', {
      message: message.trim(),
      room: room,
      username: this.currentUser?.username || 'Anonymous'
    });
  }

  joinRoom(roomId: string): void {
    if (!this.socket || !this.isConnected) {
      console.warn('⚠️ Cannot join room: not connected');
      return;
    }

    console.log('🏠 Joining room:', roomId);
    this.socket.emit('join_room', { room: roomId });
  }

  leaveRoom(roomId: string): void {
    if (!this.socket || !this.isConnected) {
      console.warn('⚠️ Cannot leave room: not connected');
      return;
    }

    console.log('🚪 Leaving room:', roomId);
    this.socket.emit('leave_room', { room: roomId });
  }

  // Event listener management
  on(event: string, callback: Function): void {
    if (!this.eventListeners[event]) {
      this.eventListeners[event] = [];
    }
    this.eventListeners[event].push(callback);
  }

  off(event: string, callback?: Function): void {
    if (!this.eventListeners[event]) return;
    
    if (callback) {
      this.eventListeners[event] = this.eventListeners[event].filter(cb => cb !== callback);
    } else {
      this.eventListeners[event] = [];
    }
  }

  private triggerEvent(event: string, data?: any): void {
    if (this.eventListeners[event]) {
      this.eventListeners[event].forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in event listener for ${event}:`, error);
        }
      });
    }
  }

  // Connection status
  getConnectionStatus(): boolean {
    return this.isConnected && this.socket?.connected === true;
  }

  getCurrentUser(): ChatUser | null {
    return this.currentUser;
  }

  // Disconnect
  disconnect(): void {
    if (this.socket) {
      console.log('🔌 Disconnecting from chat server');
      this.socket.disconnect();
      this.socket = null;
    }
    
    this.isConnected = false;
    this.currentUser = null;
    this.eventListeners = {};
  }

  // Reconnect
  reconnect(token: string, userId: string, username?: string): void {
    console.log('🔄 Reconnecting to chat server');
    this.disconnect();
    setTimeout(() => {
      this.connect(token, userId, username);
    }, 1000);
  }
}

// Export singleton instance
export default new ChatService();
export type { ChatMessage, ChatUser };

==== Frontend Service: gameResultsService.ts ==== (frontend/src/services/gameResultsService.ts)
// src/services/gameResultsService.ts
// CLEAN Game Results Service - REAL API ONLY

import { apiService } from "./apiService";

export interface GameResult {
  id: number;
  game_type: string;
  opponent: {
    id: number;
    username: string;
    full_name: string;
    level: number;
  };
  result: "win" | "loss" | "draw";
  score: string;
  my_score: number;
  opponent_score: number;
  played_at: string;
  duration: number;
  tournament_id?: number;
  tournament_name?: string;
  location: string;
  notes?: string;
  can_edit: boolean;
}

export interface GameStatistics {
  overall: {
    games_played: number;
    games_won: number;
    games_lost: number;
    games_drawn: number;
    win_rate: number;
    goals_scored: number;
    goals_conceded: number;
    goal_difference: number;
    average_game_duration: number;
    favorite_location: string;
    total_playtime: number;
  };
  by_game_type: Record<
    string,
    {
      games: number;
      wins: number;
      win_rate: number;
    }
  >;
  recent_performance: {
    last_5_games: string[];
    trend: "improving" | "declining" | "stable";
  };
  achievements: Array<{
    id: number;
    name: string;
    description: string;
    earned_at: string;
  }>;
}

export interface CreateGameResultData {
  opponent_id: number;
  game_type: string;
  result: "win" | "loss" | "draw";
  my_score: number;
  opponent_score: number;
  duration: number;
  location: string;
  tournament_id?: number;
  notes?: string;
  played_at?: string;
}

export const gameResultsService = {
  // Game history
  async getGameHistory(
    page = 1,
    limit = 10,
    filters: {
      search?: string;
      game_type?: string;
      result?: string;
      opponent_id?: number;
      tournament_id?: number;
      date_from?: string;
      date_to?: string;
    } = {}
  ): Promise<{
    results: GameResult[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    try {
      const response = await apiService.get("/game-results/", {
        params: {
          page,
          limit,
          ...filters,
        },
      });
      return response.data;
    } catch (error) {
      console.warn("Game results API failed:", error);
      // Return empty data structure instead of throwing
      return {
        results: [],
        total: 0,
        page: 1,
        totalPages: 0,
      };
    }
  },

  async getGameResult(gameId: number): Promise<GameResult> {
    const response = await apiService.get(`/game-results/${gameId}/`);
    return response.data;
  },

  // Recent results
  async getRecentResults(limit = 5): Promise<GameResult[]> {
    try {
      const response = await apiService.get("/game-results/recent/", {
        params: { limit },
      });
      return response.data;
    } catch (error) {
      console.warn("Recent results API failed:", error);
      return [];
    }
  },

  // ✅ CLEAN: Statistics - ONLY REAL API CALLS
  async getStatistics(
    timeframe: "all" | "30days" | "7days" = "all"
  ): Promise<GameStatistics> {
    try {
      const response = await apiService.get("/game-results/statistics/", {
        params: { timeframe },
      });
      return response.data;
    } catch (error) {
      console.warn("Statistics API failed:", error);

      // ✅ Return default structure if API fails
      // This will be caught by Dashboard and handled appropriately
      throw error; // Let Dashboard handle the fallback
    }
  },

  async getOpponentStats(opponentId: number): Promise<{
    games_played: number;
    wins: number;
    losses: number;
    draws: number;
    last_game?: GameResult;
  }> {
    try {
      const response = await apiService.get(
        `/game-results/opponent/${opponentId}/stats/`
      );
      return response.data;
    } catch (error) {
      console.warn("Opponent stats API failed:", error);
      return {
        games_played: 0,
        wins: 0,
        losses: 0,
        draws: 0,
      };
    }
  },

  // Create new game result
  async createGameResult(data: CreateGameResultData): Promise<GameResult> {
    const response = await apiService.post("/game-results/", data);
    return response.data;
  },

  // Update game result
  async updateGameResult(
    gameId: number,
    data: Partial<CreateGameResultData>
  ): Promise<GameResult> {
    const response = await apiService.put(`/game-results/${gameId}/`, data);
    return response.data;
  },

  // Delete game result
  async deleteGameResult(gameId: number): Promise<void> {
    await apiService.delete(`/game-results/${gameId}/`);
  },

  // Get user achievements
  async getUserAchievements(userId?: number): Promise<any[]> {
    try {
      const endpoint = userId
        ? `/game-results/achievements/${userId}`
        : "/game-results/achievements/me";
      const response = await apiService.get(endpoint);
      return response.data;
    } catch (error) {
      console.warn("Achievements API failed:", error);
      return [];
    }
  },
};


==== Frontend Service: index.ts ==== (frontend/src/services/index.ts)
// Export all services
export { apiService } from "./apiService";
export { authService } from "./authService";
export { tournamentService } from "./tournamentService";
export { locationService } from "./locationService";
export { weatherService } from "./weatherService";
export { socialService } from "./socialService";
export { gameResultsService } from "./gameResultsService";

// Export types
export type { User, Friend, FriendRequest, Challenge } from "./socialService";
export type {
  GameResult,
  GameStatistics,
  CreateGameResultData,
} from "./gameResultsService";


==== Frontend Service: moderationApi.ts ==== (frontend/src/services/moderationApi.ts)
// frontend/src/services/moderationApi.ts
// API service for moderation endpoints

import {
  AdminUser,
  Violation,
  ViolationCreate,
  BulkUserOperation,
  BulkOperationResult,
  UserReport,
} from "../types/moderation";
import config from "../config/environment";

const API_BASE = config.API_URL;

// Enhanced error types for better error handling
interface ApiError extends Error {
  status?: number;
  code?: string;
  details?: any;
}

class ModerationApiService {
  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const token = localStorage.getItem("auth_token");

    try {
      const response = await fetch(`${API_BASE}${endpoint}`, {
        headers: {
          "Content-Type": "application/json",
          ...(token && { Authorization: `Bearer ${token}` }),
          ...options.headers,
        },
        ...options,
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => null);

        // Create enhanced error object
        const error: ApiError = new Error(
          errorData?.detail ||
            this.getStatusErrorMessage(response.status) ||
            `HTTP ${response.status}: ${response.statusText}`
        );

        error.status = response.status;
        error.code = errorData?.code;
        error.details = errorData;

        // Log error for debugging
        console.error(`API Error [${response.status}] ${endpoint}:`, {
          status: response.status,
          statusText: response.statusText,
          errorData,
          endpoint,
          method: options.method || "GET",
        });

        throw error;
      }

      return response.json();
    } catch (error) {
      // Handle network errors
      if (error instanceof TypeError && error.message.includes("fetch")) {
        const networkError: ApiError = new Error(
          "Network error: Please check your internet connection and try again."
        );
        networkError.code = "NETWORK_ERROR";
        throw networkError;
      }

      // Re-throw API errors
      throw error;
    }
  }

  private getStatusErrorMessage(status: number): string {
    switch (status) {
      case 400:
        return "Bad request: Please check your input and try again.";
      case 401:
        return "Unauthorized: Please log in again.";
      case 403:
        return "Forbidden: You do not have permission to perform this action.";
      case 404:
        return "Not found: The requested resource could not be found.";
      case 409:
        return "Conflict: This operation conflicts with existing data.";
      case 422:
        return "Validation error: Please check your input data.";
      case 429:
        return "Too many requests: Please wait and try again.";
      case 500:
        return "Server error: Something went wrong on our end.";
      case 503:
        return "Service unavailable: The server is temporarily unavailable.";
      default:
        return `Request failed with status ${status}`;
    }
  }

  // User management
  async getUser(userId: number): Promise<AdminUser> {
    try {
      return await this.request<AdminUser>(`/api/admin/users/${userId}`);
    } catch (error) {
      console.error(`Failed to get user ${userId}:`, error);
      throw error;
    }
  }

  async updateUser(
    userId: number,
    updates: Partial<AdminUser>
  ): Promise<AdminUser> {
    return this.request<AdminUser>(`/api/admin/users/${userId}`, {
      method: "PATCH",
      body: JSON.stringify(updates),
    });
  }

  async getUsers(params?: {
    page?: number;
    limit?: number;
    search?: string;
  }): Promise<{
    users: AdminUser[];
    total: number;
    page: number;
    limit: number;
  }> {
    const queryString = params
      ? new URLSearchParams(params as any).toString()
      : "";

    return this.request<{
      users: AdminUser[];
      total: number;
      page: number;
      limit: number;
    }>(`/api/admin/users${queryString ? `?${queryString}` : ""}`);
  }

  // Violation management
  async getUserViolations(userId: number): Promise<Violation[]> {
    return this.request<Violation[]>(`/api/admin/users/${userId}/violations`);
  }

  async addViolation(
    userId: number,
    violation: ViolationCreate
  ): Promise<Violation> {
    try {
      return await this.request<Violation>(
        `/api/admin/users/${userId}/violations`,
        {
          method: "POST",
          body: JSON.stringify(violation),
        }
      );
    } catch (error) {
      console.error(`Failed to add violation for user ${userId}:`, error);
      throw error;
    }
  }

  async updateViolation(
    userId: number,
    violationId: number,
    updates: Partial<Violation>
  ): Promise<Violation> {
    return this.request<Violation>(
      `/api/admin/users/${userId}/violations/${violationId}`,
      {
        method: "PATCH",
        body: JSON.stringify(updates),
      }
    );
  }

  async deleteViolation(userId: number, violationId: number): Promise<void> {
    return this.request<void>(
      `/api/admin/users/${userId}/violations/${violationId}`,
      { method: "DELETE" }
    );
  }

  // Bulk operations
  async bulkUserOperation(
    operation: BulkUserOperation
  ): Promise<BulkOperationResult> {
    return this.request<BulkOperationResult>("/api/admin/users/bulk", {
      method: "POST",
      body: JSON.stringify(operation),
    });
  }

  // Moderation logs
  async getModerationLogs(params?: {
    page?: number;
    limit?: number;
    actor_id?: number;
    target_user_id?: number;
  }): Promise<{
    logs: any[];
    total: number;
    page: number;
    limit: number;
  }> {
    const queryString = params
      ? new URLSearchParams(params as any).toString()
      : "";

    return this.request<{
      logs: any[];
      total: number;
      page: number;
      limit: number;
    }>(`/api/admin/moderation/logs${queryString ? `?${queryString}` : ""}`);
  }

  // Reports
  async getReports(status?: string): Promise<UserReport[]> {
    const queryString = status ? `?status=${status}` : "";
    return this.request<UserReport[]>(`/api/admin/reports${queryString}`);
  }

  async updateReport(
    reportId: number,
    action: "dismiss" | "create_violation" | "escalate",
    data?: any
  ): Promise<UserReport> {
    return this.request<UserReport>(`/api/admin/reports/${reportId}`, {
      method: "PATCH",
      body: JSON.stringify({ action, ...data }),
    });
  }
}

export const moderationApi = new ModerationApiService();


==== Frontend Service: socialService.ts ==== (frontend/src/services/socialService.ts)
import { apiService } from "./apiService";

export interface User {
  id: number;
  username: string;
  full_name: string;
  email: string;
  level: number;
  credits: number;
  is_online: boolean;
  last_seen?: string;
  profile_picture?: string;
  stats?: {
    games_played: number;
    games_won: number;
    win_rate: number;
  };
}

export interface Friend {
  id: number;
  user: User;
  status: "pending" | "accepted" | "blocked";
  created_at: string;
}

export interface FriendRequest {
  id: number;
  sender: User;
  recipient: User;
  status: "pending" | "accepted" | "declined";
  created_at: string;
}

export interface Challenge {
  id: number;
  challenger: User;
  challenged: User;
  game_type: string;
  location_id?: number;
  location_name?: string;
  scheduled_time?: string;
  message?: string;
  status: "pending" | "accepted" | "declined" | "completed" | "cancelled";
  created_at: string;
}

export const socialService = {
  // Friends management
  async getFriends(): Promise<Friend[]> {
    const response = await apiService.get("/social/friends/");
    return response.data;
  },

  async removeFriend(friendId: number): Promise<void> {
    await apiService.delete(`/social/friends/${friendId}/`);
  },

  // User search and discovery
  async searchUsers(
    query: string,
    page = 1
  ): Promise<{
    results: User[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const response = await apiService.get("/social/users/search/", {
      params: { q: query, page },
    });
    return response.data;
  },

  async getUserProfile(userId: number): Promise<User> {
    const response = await apiService.get(`/users/${userId}/`);
    return response.data;
  },

  // Friend requests
  async getFriendRequests(
    type: "sent" | "received" | "all" = "all"
  ): Promise<FriendRequest[]> {
    const response = await apiService.get("/social/friend-requests/", {
      params: { type },
    });
    return response.data;
  },

  async sendFriendRequest(
    userId: number,
    message?: string
  ): Promise<FriendRequest> {
    const response = await apiService.post("/social/friend-requests/", {
      recipient_id: userId,
      message,
    });
    return response.data;
  },

  async respondToFriendRequest(
    requestId: number,
    action: "accept" | "decline"
  ): Promise<void> {
    await apiService.patch(`/social/friend-requests/${requestId}/`, {
      accept: action === "accept",
    });
  },

  async cancelFriendRequest(requestId: number): Promise<void> {
    await apiService.delete(`/social/friend-requests/${requestId}/`);
  },

  // Challenges
  async getChallenges(
    type: "sent" | "received" | "all" = "all"
  ): Promise<Challenge[]> {
    const response = await apiService.get("/social/challenges/", {
      params: { type },
    });
    return response.data;
  },

  async sendChallenge(data: {
    challenged_user_id: number;
    game_type: string;
    location_id?: number;
    scheduled_time?: string;
    message?: string;
  }): Promise<Challenge> {
    const response = await apiService.post("/social/challenges/", data);
    return response.data;
  },

  async respondToChallenge(
    challengeId: number,
    action: "accept" | "decline"
  ): Promise<void> {
    await apiService.patch(`/social/challenges/${challengeId}/`, {
      status: action === "accept" ? "accepted" : "declined",
    });
  },

  async cancelChallenge(challengeId: number): Promise<void> {
    await apiService.delete(`/social/challenges/${challengeId}/`);
  },

  // Utility functions
  async checkFriendshipStatus(
    userId: number
  ): Promise<"none" | "pending" | "friends" | "blocked"> {
    const response = await apiService.get(
      `/social/friendship-status/${userId}/`
    );
    return response.data.status;
  },

  async blockUser(userId: number): Promise<void> {
    await apiService.post(`/social/block/${userId}/`);
  },

  async unblockUser(userId: number): Promise<void> {
    await apiService.delete(`/social/block/${userId}/`);
  },

  async getOnlineFriends(): Promise<User[]> {
    const response = await apiService.get("/social/friends/online/");
    return response.data;
  },

  async updateOnlineStatus(isOnline: boolean): Promise<void> {
    await apiService.patch("/social/status/", { is_online: isOnline });
  },
};


==== Frontend Service: tokenManager.ts ==== (frontend/src/services/tokenManager.ts)
import config from '../config/environment';

export class TokenManager {
  private static refreshTimer: NodeJS.Timeout | null = null;
  private static isRefreshing = false;
  private static refreshPromise: Promise<any> | null = null;

  static getAccessToken(): string | null {
    return localStorage.getItem('access_token');
  }

  static getRefreshToken(): string | null {
    return localStorage.getItem('refresh_token');
  }

  static setTokens(accessToken: string, refreshToken: string, expiresIn: number) {
    localStorage.setItem('access_token', accessToken);
    localStorage.setItem('refresh_token', refreshToken);
    
    // Calculate expiration time
    const expirationTime = Date.now() + (expiresIn * 1000);
    localStorage.setItem('token_expires_at', expirationTime.toString());
    
    // Schedule auto-refresh 5 minutes before expiry
    this.scheduleAutoRefresh(expiresIn);
  }

  static clearTokens() {
    localStorage.removeItem('access_token');
    localStorage.removeItem('refresh_token');
    localStorage.removeItem('token_expires_at');
    
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
      this.refreshTimer = null;
    }
  }

  static isTokenExpired(): boolean {
    const expirationTime = localStorage.getItem('token_expires_at');
    if (!expirationTime) return true;
    
    return Date.now() >= parseInt(expirationTime);
  }

  static isTokenExpiringSoon(minutesBeforeExpiry: number = 5): boolean {
    const expirationTime = localStorage.getItem('token_expires_at');
    if (!expirationTime) return true;
    
    const timeUntilExpiry = parseInt(expirationTime) - Date.now();
    const minutesUntilExpiry = timeUntilExpiry / (1000 * 60);
    
    return minutesUntilExpiry <= minutesBeforeExpiry;
  }

  static scheduleAutoRefresh(expiresIn: number) {
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
    }

    // Schedule refresh 5 minutes before expiry
    const refreshTime = Math.max((expiresIn - 300) * 1000, 60000); // At least 1 minute
    
    this.refreshTimer = setTimeout(async () => {
      try {
        await this.refreshAccessToken();
      } catch (error) {
        console.error('Auto-refresh failed:', error);
        // Redirect to login on refresh failure
        this.clearTokens();
        window.location.href = '/login';
      }
    }, refreshTime);
  }

  static async refreshAccessToken(): Promise<any> {
    // Prevent multiple simultaneous refresh attempts
    if (this.isRefreshing && this.refreshPromise) {
      return this.refreshPromise;
    }

    this.isRefreshing = true;
    
    this.refreshPromise = this.performTokenRefresh();
    
    try {
      const result = await this.refreshPromise;
      this.isRefreshing = false;
      this.refreshPromise = null;
      return result;
    } catch (error) {
      this.isRefreshing = false;
      this.refreshPromise = null;
      throw error;
    }
  }

  private static async performTokenRefresh(): Promise<any> {
    const refreshToken = this.getRefreshToken();
    
    if (!refreshToken) {
      throw new Error('No refresh token available');
    }

    const response = await fetch(`${config.API_URL}/api/auth/refresh`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        refresh_token: refreshToken
      })
    });

    if (!response.ok) {
      if (response.status === 401) {
        throw new Error('Refresh token expired');
      }
      throw new Error('Token refresh failed');
    }

    const data = await response.json();
    
    if (data.success) {
      const tokenData = data.data;
      this.setTokens(
        tokenData.access_token,
        tokenData.refresh_token,
        tokenData.expires_in
      );
      
      console.log('✅ Access token refreshed successfully');
      return tokenData;
    } else {
      throw new Error(data.error?.message || 'Token refresh failed');
    }
  }

  static async getValidAccessToken(): Promise<string | null> {
    const accessToken = this.getAccessToken();
    
    if (!accessToken) {
      return null;
    }

    // If token is expiring soon, refresh it
    if (this.isTokenExpiringSoon()) {
      try {
        await this.refreshAccessToken();
        return this.getAccessToken();
      } catch (error) {
        console.error('Token refresh failed:', error);
        return null;
      }
    }

    return accessToken;
  }

  static initializeFromStorage() {
    const expirationTime = localStorage.getItem('token_expires_at');
    
    if (expirationTime && !this.isTokenExpired()) {
      const remainingTime = parseInt(expirationTime) - Date.now();
      const remainingSeconds = Math.floor(remainingTime / 1000);
      
      if (remainingSeconds > 300) { // More than 5 minutes remaining
        this.scheduleAutoRefresh(remainingSeconds);
      } else {
        // Token expires soon, refresh immediately
        this.refreshAccessToken().catch(error => {
          console.error('Initial token refresh failed:', error);
          this.clearTokens();
        });
      }
    }
  }
}

==== Frontend Service: tournamentService.ts ==== (frontend/src/services/tournamentService.ts)
// src/services/tournamentService.ts
// LFA Legacy GO - Tournament Service for API Integration

import { ApiService } from "./api";

// Tournament Types
export interface Tournament {
  id: number;
  tournament_id: string;
  name: string;
  description?: string;
  tournament_type: string;
  game_type: string;
  format: string;
  status: string;
  location_id: number;
  location_name: string;
  start_time: string;
  end_time: string;
  registration_deadline: string;
  min_participants: number;
  max_participants: number;
  current_participants: number;
  entry_fee_credits: number;
  prize_pool_credits: number;
  min_level: number;
  max_level?: number;
  organizer_id: number;
  organizer_username: string;
  winner_id?: number;
  winner_username?: string;
  is_registration_open: boolean;
  is_full: boolean;
  can_start: boolean;
  created_at: string;
}

export interface Participant {
  id: number;
  user_id: number;
  username: string;
  full_name: string;
  level: number;
  registration_time: string;
  status: string;
  current_round: number;
  matches_played: number;
  matches_won: number;
  matches_lost: number;
  total_score: number;
  average_score: number;
  points: number;
  final_position?: number;
  prize_won: number;
  performance_rating: number;
}

export interface Match {
  id: string;
  match_id: string;
  round_number: number;
  match_number: number;
  tournament_id: number;
  player1_id: number;
  player1_username: string;
  player1_full_name: string;
  player2_id?: number;
  player2_username?: string;
  player2_full_name?: string;
  status: "scheduled" | "in_progress" | "completed" | "pending";
  player1_score?: number;
  player2_score?: number;
  winner_id?: number;
  scheduled_time: string;
  actual_start_time?: string;
  completed_at?: string;
  duration_minutes?: number;
  match_notes?: string;
  competitiveness_score?: number;
}

export interface TournamentDetails {
  tournament: Tournament;
  participants: Participant[];
  bracket?: any;
  current_round: number;
  total_rounds: number;
  user_participation?: Participant;
  can_register: boolean;
  can_withdraw: boolean;
  upcoming_matches: Match[];
  completed_matches: Match[];
  tournament_rules: {
    format: string;
    entry_fee: number;
    min_participants: number;
    max_participants: number;
    prize_distribution: Record<string, number>;
    level_requirements: {
      min_level: number;
      max_level?: number;
    };
  };
}

export interface CreateTournamentRequest {
  name: string;
  description?: string;
  tournament_type: string;
  game_type: string;
  format: string;
  location_id: number;
  start_time: string;
  end_time: string;
  registration_deadline: string;
  min_participants: number;
  max_participants: number;
  entry_fee_credits: number;
  prize_distribution: Record<string, number>;
  min_level: number;
  max_level?: number;
}

export interface MatchResultSubmission {
  player1_score: number;
  player2_score: number;
  winner_id: number;
  actual_start_time?: string;
  actual_end_time?: string;
  match_notes?: string;
  duration_minutes?: number;
  competitiveness_score?: number;
}

export class TournamentService extends ApiService {
  private readonly baseUrl = "/api/tournaments";

  // Tournament Management
  async getAllTournaments(): Promise<Tournament[]> {
    return this.get(this.baseUrl);
  }

  async getTournamentById(tournamentId: number): Promise<TournamentDetails> {
    return this.get(`${this.baseUrl}/${tournamentId}`);
  }

  async createTournament(
    tournament: CreateTournamentRequest
  ): Promise<Tournament> {
    return this.post(this.baseUrl, tournament);
  }

  async updateTournament(
    tournamentId: number,
    updates: Partial<Tournament>
  ): Promise<Tournament> {
    return this.put(`${this.baseUrl}/${tournamentId}`, updates);
  }

  async deleteTournament(tournamentId: number): Promise<{ message: string }> {
    return this.delete(`${this.baseUrl}/${tournamentId}`);
  }

  // Registration Management
  async registerForTournament(
    tournamentId: number
  ): Promise<{ message: string; participant: Participant }> {
    return this.post(`${this.baseUrl}/${tournamentId}/register`);
  }

  async withdrawFromTournament(
    tournamentId: number
  ): Promise<{ message: string }> {
    return this.delete(`${this.baseUrl}/${tournamentId}/register`);
  }

  async getTournamentParticipants(
    tournamentId: number
  ): Promise<Participant[]> {
    return this.get(`${this.baseUrl}/${tournamentId}/participants`);
  }

  // Bracket & Match Management
  async getTournamentBracket(tournamentId: number): Promise<{
    tournament_id: number;
    rounds: Array<{
      round_number: number;
      matches: Match[];
    }>;
    current_round: number;
    total_rounds: number;
  }> {
    return this.get(`${this.baseUrl}/${tournamentId}/bracket`);
  }

  async getTournamentMatches(
    tournamentId: number,
    status?: string
  ): Promise<Match[]> {
    const params = status ? `?status=${status}` : "";
    return this.get(`${this.baseUrl}/${tournamentId}/matches${params}`);
  }

  async getMatchDetails(tournamentId: number, matchId: string): Promise<Match> {
    return this.get(`${this.baseUrl}/${tournamentId}/matches/${matchId}`);
  }

  async updateMatchStatus(
    tournamentId: number,
    matchId: string,
    status: "scheduled" | "in_progress" | "completed"
  ): Promise<Match> {
    return this.put(
      `${this.baseUrl}/${tournamentId}/matches/${matchId}/status`,
      { status }
    );
  }

  async submitMatchResult(
    tournamentId: number,
    matchId: string,
    result: MatchResultSubmission
  ): Promise<Match> {
    return this.post(
      `${this.baseUrl}/${tournamentId}/matches/${matchId}/result`,
      result
    );
  }

  async rescheduleMatch(
    tournamentId: number,
    matchId: string,
    newTime: string
  ): Promise<Match> {
    return this.put(
      `${this.baseUrl}/${tournamentId}/matches/${matchId}/schedule`,
      {
        scheduled_time: newTime,
      }
    );
  }

  // Tournament Control (Organizer only)
  async startTournament(
    tournamentId: number
  ): Promise<{ message: string; tournament: Tournament }> {
    return this.post(`${this.baseUrl}/${tournamentId}/start`);
  }

  async endTournament(
    tournamentId: number
  ): Promise<{ message: string; tournament: Tournament }> {
    return this.post(`${this.baseUrl}/${tournamentId}/end`);
  }

  async cancelTournament(
    tournamentId: number,
    reason?: string
  ): Promise<{ message: string }> {
    return this.post(`${this.baseUrl}/${tournamentId}/cancel`, { reason });
  }

  async generateBracket(
    tournamentId: number
  ): Promise<{ message: string; bracket: any }> {
    return this.post(`${this.baseUrl}/${tournamentId}/generate-bracket`);
  }

  // Statistics & Analytics
  async getTournamentStatistics(tournamentId: number): Promise<{
    tournament_id: number;
    total_matches: number;
    completed_matches: number;
    average_match_duration: number;
    average_competitiveness: number;
    participant_stats: Array<{
      user_id: number;
      username: string;
      full_name: string;
      matches_played: number;
      matches_won: number;
      win_rate: number;
      average_score: number;
      performance_rating: number;
    }>;
  }> {
    return this.get(`${this.baseUrl}/${tournamentId}/statistics`);
  }

  async getUserTournamentHistory(userId?: number): Promise<{
    user_id: number;
    tournaments_participated: number;
    tournaments_won: number;
    tournaments_organized: number;
    total_matches_played: number;
    total_matches_won: number;
    win_rate: number;
    average_placement: number;
    total_credits_earned: number;
    total_credits_spent: number;
    favorite_tournament_type: string;
    recent_tournaments: Tournament[];
  }> {
    const endpoint = userId
      ? `${this.baseUrl}/user/${userId}/history`
      : `${this.baseUrl}/user/me/history`;
    return this.get(endpoint);
  }

  // Search & Filtering
  async searchTournaments(params: {
    search?: string;
    status?: string;
    tournament_type?: string;
    format?: string;
    location_id?: number;
    min_level?: number;
    max_level?: number;
    entry_fee_min?: number;
    entry_fee_max?: number;
    start_date?: string;
    end_date?: string;
    page?: number;
    limit?: number;
  }): Promise<{
    tournaments: Tournament[];
    total_count: number;
    page: number;
    total_pages: number;
  }> {
    const queryParams = new URLSearchParams();

    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined && value !== null && value !== "") {
        queryParams.append(key, value.toString());
      }
    });

    return this.get(`${this.baseUrl}/search?${queryParams.toString()}`);
  }

  // Leaderboards
  async getTournamentLeaderboard(tournamentId: number): Promise<{
    tournament_id: number;
    leaderboard: Array<{
      position: number;
      user_id: number;
      username: string;
      full_name: string;
      points: number;
      matches_won: number;
      matches_played: number;
      win_rate: number;
      average_score: number;
      prize_won: number;
    }>;
  }> {
    return this.get(`${this.baseUrl}/${tournamentId}/leaderboard`);
  }

  async getGlobalTournamentLeaderboard(params?: {
    tournament_type?: string;
    time_period?: "week" | "month" | "year" | "all";
    limit?: number;
  }): Promise<{
    leaderboard: Array<{
      position: number;
      user_id: number;
      username: string;
      full_name: string;
      tournaments_won: number;
      total_tournaments: number;
      win_rate: number;
      total_credits_earned: number;
      performance_rating: number;
    }>;
    time_period: string;
    updated_at: string;
  }> {
    const queryParams = new URLSearchParams();

    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          queryParams.append(key, value.toString());
        }
      });
    }

    return this.get(`${this.baseUrl}/leaderboard?${queryParams.toString()}`);
  }

  // Template Management
  async getTournamentTemplates(): Promise<
    Array<{
      id: string;
      name: string;
      description: string;
      tournament_type: string;
      format: string;
      min_participants: number;
      max_participants: number;
      entry_fee_credits: number;
      prize_distribution: Record<string, number>;
      level_requirements: {
        min_level: number;
        max_level?: number;
      };
    }>
  > {
    return this.get(`${this.baseUrl}/templates`);
  }

  async createTournamentFromTemplate(
    templateId: string,
    overrides: {
      name: string;
      description?: string;
      location_id: number;
      start_time: string;
      registration_deadline: string;
    }
  ): Promise<Tournament> {
    return this.post(
      `${this.baseUrl}/templates/${templateId}/create`,
      overrides
    );
  }

  // Notifications & Events
  async subscribeTournamentUpdates(
    tournamentId: number
  ): Promise<{ message: string }> {
    return this.post(`${this.baseUrl}/${tournamentId}/subscribe`);
  }

  async unsubscribeTournamentUpdates(
    tournamentId: number
  ): Promise<{ message: string }> {
    return this.delete(`${this.baseUrl}/${tournamentId}/subscribe`);
  }

  // Validation & Helper Methods
  validateTournamentData(tournament: CreateTournamentRequest): string[] {
    const errors: string[] = [];

    if (!tournament.name || tournament.name.trim().length < 3) {
      errors.push("Tournament name must be at least 3 characters long");
    }

    if (!tournament.start_time) {
      errors.push("Start time is required");
    }

    if (!tournament.registration_deadline) {
      errors.push("Registration deadline is required");
    }

    if (
      new Date(tournament.registration_deadline) >=
      new Date(tournament.start_time)
    ) {
      errors.push("Registration deadline must be before start time");
    }

    if (tournament.min_participants < 2) {
      errors.push("Minimum participants must be at least 2");
    }

    if (tournament.max_participants < tournament.min_participants) {
      errors.push(
        "Maximum participants must be greater than minimum participants"
      );
    }

    if (tournament.entry_fee_credits < 0) {
      errors.push("Entry fee cannot be negative");
    }

    if (tournament.min_level < 1 || tournament.min_level > 10) {
      errors.push("Minimum level must be between 1 and 10");
    }

    if (tournament.max_level && tournament.max_level < tournament.min_level) {
      errors.push("Maximum level must be greater than minimum level");
    }

    return errors;
  }

  formatTournamentTime(dateString: string): string {
    return new Date(dateString).toLocaleString("hu-HU", {
      year: "numeric",
      month: "long",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
  }

  calculateTournamentDuration(startTime: string, endTime: string): number {
    const start = new Date(startTime);
    const end = new Date(endTime);
    return Math.floor((end.getTime() - start.getTime()) / (1000 * 60)); // minutes
  }

  getTournamentStatusDisplayName(status: string): string {
    switch (status) {
      case "registration":
        return "Registration Open";
      case "in_progress":
        return "In Progress";
      case "completed":
        return "Completed";
      case "cancelled":
        return "Cancelled";
      default:
        return status.replace("_", " ");
    }
  }

  getTournamentTypeDisplayName(type: string): string {
    switch (type) {
      case "daily_challenge":
        return "Daily Challenge";
      case "weekly_challenge":
        return "Weekly Challenge";
      case "championship":
        return "Championship";
      case "beginner_friendly":
        return "Beginner Friendly";
      case "elite_series":
        return "Elite Series";
      default:
        return type.replace("_", " ");
    }
  }

  getFormatDisplayName(format: string): string {
    switch (format) {
      case "single_elimination":
        return "Single Elimination";
      case "double_elimination":
        return "Double Elimination";
      case "round_robin":
        return "Round Robin";
      case "swiss_system":
        return "Swiss System";
      default:
        return format.replace("_", " ");
    }
  }
}

// Export service instance
export const tournamentService = new TournamentService();

// Export default for convenience
export default tournamentService;

⚙️  KRITIKUS KONFIGURÁCIÓK
===========================

==== Root Package Config ==== (package.json)
{
  "name": "lfa-legacy-go-automation",
  "version": "1.0.0",
  "description": "LFA Legacy GO - Deployment testing",
  "private": true,
  "type": "module",
  "scripts": {
    "test:quick": "node test/quick-deployment-check.js",
    "test:auto": "node test/automated-integration-test.js",
    "test:api": "curl -s https://lfa-legacy-go-backend-376491487980.us-central1.run.app/health",
    "test:all": "npm run test:quick && echo '✅ Gyors teszt kész!' && echo 'Telepítsd a Puppeteer-t a teljes teszthez: npm install puppeteer chalk'",
    "install:test-deps": "npm install puppeteer chalk node-fetch --save-dev"
  },
  "devDependencies": {
    "chalk": "^5.0.0",
    "node-fetch": "^3.3.0"
  },
  "optionalDependencies": {
    "puppeteer": "^24.16.2"
  },
  "dependencies": {
    "@playwright/test": "^1.55.0",
    "axios": "^1.11.0",
    "playwright": "^1.55.0"
  }
}


==== Docker Compose ==== (docker-compose.yml)
# =============================================
# LFA LEGACY GO - DOCKER COMPOSE
# Local development environment
# =============================================

version: '3.8'

services:
  # =============================================
  # DATABASE SERVICE
  # =============================================
  postgres:
    image: postgres:15-alpine
    container_name: lfa-postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: lfa_legacy_go
      POSTGRES_USER: lfa_user
      POSTGRES_PASSWORD: lfa_password
      POSTGRES_HOST_AUTH_METHOD: trust
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backend/database/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    networks:
      - lfa-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U lfa_user -d lfa_legacy_go"]
      interval: 10s
      timeout: 5s
      retries: 5

  # =============================================
  # BACKEND API SERVICE
  # =============================================
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
      args:
        BUILD_DATE: ${BUILD_DATE:-2024-01-01}
        VERSION: ${VERSION:-dev}
    container_name: lfa-backend
    restart: unless-stopped
    ports:
      - "8080:8080"
    environment:
      # Database
      DATABASE_URL: postgresql://lfa_user:lfa_password@postgres:5432/lfa_legacy_go
      
      # Security
      JWT_SECRET_KEY: dev-secret-key-change-in-production
      
      # Application
      ENVIRONMENT: development
      DEBUG: true
      CORS_ORIGINS: http://localhost:3000,http://127.0.0.1:3000
      
      # Logging
      LOG_LEVEL: INFO
    volumes:
      - ./backend:/app
      - backend_logs:/app/logs
    networks:
      - lfa-network
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # =============================================
  # FRONTEND SERVICE (Development)
  # =============================================
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.dev
      args:
        REACT_APP_API_URL: http://localhost:8080
    container_name: lfa-frontend
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      REACT_APP_API_URL: http://localhost:8080
      NODE_ENV: development
      GENERATE_SOURCEMAP: false
      NODE_OPTIONS: --max-old-space-size=4096
    volumes:
      - ./frontend/src:/app/src:ro
      - ./frontend/public:/app/public:ro
      - frontend_node_modules:/app/node_modules
    networks:
      - lfa-network
    depends_on:
      - backend
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  # =============================================
  # REDIS (Optional - for caching)
  # =============================================
  redis:
    image: redis:7-alpine
    container_name: lfa-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - lfa-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3

  # =============================================
  # AUTOMATION TESTING SERVICE
  # =============================================
  automation:
    image: mcr.microsoft.com/playwright:v1.41.0-focal
    container_name: lfa-automation
    working_dir: /tests
    environment:
      FRONTEND_URL: http://frontend:3000
      BACKEND_URL: http://backend:8080
      TEST_USERNAME: automation_user
      TEST_PASSWORD: automation123
      TEST_EMAIL: automation@lfatest.com
    volumes:
      - ./tests:/tests:ro
      - ./test-results:/tests/test-results
      - ./playwright.config.js:/tests/playwright.config.js:ro
      - ./package.json:/tests/package.json:ro
    networks:
      - lfa-network
    depends_on:
      - frontend
      - backend
    profiles:
      - testing
    command: >
      sh -c "
        npm install &&
        npx playwright test tests/automation/lfa-visual-automation.spec.js --reporter=html
      "

# =============================================
# NETWORKS
# =============================================
networks:
  lfa-network:
    driver: bridge
    name: lfa-legacy-go-network

# =============================================
# VOLUMES
# =============================================
volumes:
  postgres_data:
    name: lfa-postgres-data
  redis_data:
    name: lfa-redis-data
  backend_logs:
    name: lfa-backend-logs
  frontend_node_modules:
    name: lfa-frontend-node-modules

# =============================================
# USAGE INSTRUCTIONS
# =============================================
# 
# Start all services:
# docker-compose up -d
#
# Start specific services:
# docker-compose up postgres backend
#
# Run automation tests:
# docker-compose --profile testing up automation
#
# View logs:
# docker-compose logs -f backend
# docker-compose logs -f frontend
#
# Stop all services:
# docker-compose down
#
# Stop and remove volumes:
# docker-compose down -v
#
# Rebuild services:
# docker-compose up --build
#
# =============================================

==== Docker Configuration ==== (Dockerfile)
FROM python:3.11-slim

WORKDIR /app

# Install dependencies
RUN apt-get update && apt-get install -y gcc && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

# Expose port
EXPOSE 8080

# Use bash to read PORT environment variable
CMD ["bash", "-c", "python -m uvicorn app.main:app --host 0.0.0.0 --port ${PORT:-8080}"]


==== Postgres Environment ==== (.env.postgres)
# PostgreSQL Configuration for LFA Legacy GO
DATABASE_URL=postgresql://lfa_user:NVI29jPjzKO68kJi8SMcp4cT@localhost:5433/lfa_legacy_go
CLOUD_SQL_CONNECTION_NAME=lfa-legacy-go:europe-west1:lfa-legacy-go-postgres
POSTGRES_HOST=localhost
POSTGRES_PORT=5433
POSTGRES_DB=lfa_legacy_go
POSTGRES_USER=lfa_user
POSTGRES_PASSWORD=NVI29jPjzKO68kJi8SMcp4cT

# Connection Pool Settings
DB_POOL_SIZE=20
DB_MAX_OVERFLOW=30
DB_POOL_TIMEOUT=30
DB_POOL_RECYCLE=3600
DB_POOL_PRE_PING=true

# For production deployment
GOOGLE_CLOUD_PROJECT=lfa-legacy-go


==== Netlify Config ==== (netlify.toml)
[build]
  base = "frontend"  
  publish = "frontend/build"
  command = "npm run build"

[build.environment]
  NODE_VERSION = "18"
  NODE_OPTIONS = "--max-old-space-size=8192"
  GENERATE_SOURCEMAP = "false"
  DISABLE_ESLINT_PLUGIN = "true"
  TSC_COMPILE_ON_ERROR = "true"
  SKIP_PREFLIGHT_CHECK = "true"
  REACT_APP_API_URL = "https://lfa-legacy-go-backend-376491487980.us-central1.run.app"

# CRITICAL: Catch-all redirect for SPA
[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200

# Debug headers
[[headers]]
  for = "/*"
  [headers.values]
    X-Frame-Options = "DENY"
    X-XSS-Protection = "1; mode=block"
    Referrer-Policy = "strict-origin-when-cross-origin"
📚 KRITIKUS DOKUMENTÁCIÓ
========================

==== Project README ==== (README.md)
# LFA Legacy GO - Football Gaming Platform

## Current Progress

### ✅ Phase 1: Authentication System
- Complete user authentication with JWT tokens
- Registration, login, password reset functionality
- Role-based access control

### ✅ Phase 2: Core Gaming Features  
- Tournament system with brackets and matches
- Game results tracking and leaderboards
- Weather integration for location-based games
- Social features and friend systems

### ✅ Phase 3: Administration & Management
- Complete admin dashboard with 5-tab interface
- User management with violation tracking
- Bulk operations with progress reporting
- Moderation tools and audit logging
- Migration system with rollback support

## Quick Start

### Backend Setup
```bash
cd backend
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
pip install -r requirements.txt

# Run migrations
python run_migrations.py up

# Start server
python -m app.main
```

### Frontend Setup
```bash
cd frontend
npm install
npm start
```

### Admin Features
After starting both backend and frontend:
1. Login as admin user
2. Navigate to `/admin` for user management
3. Access moderation tools at `/admin/moderation`

## Testing

### Backend Tests
```bash
cd backend
python -m pytest tests/test_moderation_simple.py -v
```

### Frontend Tests
```bash
cd frontend
npm test -- --testPathPattern="moderation-basic"
```

## Database Migrations

### Check Status
```bash
cd backend
python run_migrations.py status
```

### Apply Migration
```bash
python run_migrations.py up
```

### Rollback Migration
```bash
python run_migrations.py down
```

## Documentation
- [Admin System Documentation](docs/admin.md)
- [API Reference](docs/admin.md#api-endpoints)  
- [Database Schema](docs/admin.md#database-schema)

---

**Latest Update**: Phase 3 Administration & Management System - Production Ready ✅


==== Claude Code Handoff ==== (CLAUDE-CODE-HANDOFF-COMPLETE.md)
# 🤖 CLAUDE CODE HANDOFF - COMPLETE ✅

## 🎉 **TELJESEN VÉGREHAJTVA!**

Minden feladat automatikusan elvégezve a Claude Code handoff specifikáció alapján.

## ✅ **ELVÉGZETT FELADATOK**

### 1. **package.json javítva** ✅
- **Előtte**: Hibás JSON syntax (ha volt)
- **Utána**: Clean, valid JSON with proper testing scripts
- **Fájl**: `package.json`

### 2. **Test infrastruktúra létrehozva** ✅
```
test/
├── quick-deployment-check.js  ✅ Zero-dependency deployment test
├── README.md                  ✅ Documentation és usage guide
```

### 3. **VSCode integráció telepítve** ✅
```
.vscode/
├── tasks.json  ✅ Hotkey support: Ctrl+Shift+P → "Tasks: Run Task"
```

### 4. **Scripts konfigurálva** ✅
```bash
npm run test:quick     # ⚡ Instant deployment test
npm run test:api       # 🔗 API health check only  
npm run test:all       # 📊 Complete test suite
```

## 🚀 **TESZTELÉSI EREDMÉNYEK**

**FIRST RUN RESULT: 3/3 TESTS PASSED! ✅**

```
⚡ LFA Legacy GO - Gyors Deployment Teszt
==================================================
✅ Backend Health: HTTP 200
✅ API Docs: HTTP 200  
✅ Frontend Status: HTTP 200

📊 ÖSSZESEN: 3/3 teszt sikeres
🎉 MINDEN TESZT SIKERES!
```

## 🎯 **IMMEDIATE USAGE**

### **Command Line**:
```bash
cd ~/Seafile/Football\ Investment/Projects/GanballGames/lfa-legacy-go
npm run test:quick
```

### **VSCode Hotkey**:
1. `Ctrl+Shift+P`
2. Type: "Tasks: Run Task"  
3. Select: "⚡ LFA Legacy GO - Gyors Teszt"

### **Automated Monitoring**:
```bash
# Every 30 seconds monitoring
watch -n 30 'npm run test:quick'
```

## 🔗 **VERIFIED WORKING ENDPOINTS**

- ✅ **Frontend**: https://lfa-legacy-go.netlify.app
- ✅ **Backend API**: https://lfa-legacy-go-backend-376491487980.us-central1.run.app/docs
- ✅ **Health Check**: https://lfa-legacy-go-backend-376491487980.us-central1.run.app/health

## 💡 **KEY INSIGHTS AUTOMATED**

### **process.env Issue Explanation** ✅
The test script automatically explains:
- `process.env.REACT_APP_API_URL` browser console errors are **NORMAL**
- `process` object only exists in Node.js, not browsers
- React build automatically injects environment variables
- The deployed app works correctly despite browser console errors

## 🏆 **ACHIEVEMENT SUMMARY**

✅ **Zero-dependency testing** (pure Node.js HTTPS)  
✅ **Instant feedback** (colorized console output)  
✅ **VSCode integration** (hotkey support)  
✅ **Production verification** (real endpoint testing)  
✅ **User education** (process.env explanation)

## 🎯 **READY FOR PRODUCTION**

The LFA Legacy GO deployment testing infrastructure is:
- **Fully automated**
- **Zero-configuration** 
- **Production-ready**
- **Developer-friendly**

**All handoff tasks completed successfully! 🤖✅**

==== Production Status ==== (PRODUCTION_READY_REPORT.md)
# 🏆 LFA Legacy GO - Production Ready Report

**Date:** August 21, 2025  
**Status:** ✅ **PRODUCTION READY**  
**Phase:** Week 4 - Railway Deployment Ready

---

## 📊 **SYSTEM STATUS**

### ✅ **Core Components - 100% Ready**

**API Framework:**
- ✅ FastAPI 3.0.0 with production configuration  
- ✅ All 11/11 routers active and tested
- ✅ Comprehensive middleware stack
- ✅ Standardized response formats
- ✅ Request ID tracking and logging

**Database Layer:**  
- ✅ PostgreSQL production configuration
- ✅ Connection pooling (10 connections + 20 overflow)
- ✅ SQLite fallback for development
- ✅ Database migration scripts ready
- ✅ Health check and monitoring

**Security & Performance:**
- ✅ Security headers (OWASP compliance)  
- ✅ Rate limiting (100 req/60s)
- ✅ CORS configuration
- ✅ Request size limiting (10MB)
- ✅ Error handling and logging

---

## 🧪 **TESTING RESULTS**

### **Local Production Testing**
```
✅ Root Endpoint: 200 (13.63ms)
✅ Health Check: 200 (healthy)  
✅ API Status: 200 (all routers active)
✅ Performance Metrics: Available
✅ API Documentation: /docs working
```

### **API Standards Compliance**
```
✅ Consistent response format
✅ Request ID tracking  
✅ Timestamp on all responses
✅ Error handling with proper codes
✅ Health check endpoints
✅ Performance monitoring endpoints
```

### **Router Status - 11/11 Active**
```
✅ auth: Authentication & authorization
✅ credits: Credit system management
✅ social: Friends, challenges, social features  
✅ locations: Training location services
✅ booking: Session booking & scheduling
✅ tournaments: Tournament management
✅ game_results: Game results & statistics
✅ weather: Weather information services
✅ admin: Administrative functions
✅ health: Health checks & monitoring
✅ frontend_errors: Error tracking
```

---

## 🚀 **DEPLOYMENT CONFIGURATION**

### **Railway Deployment - Ready**
- ✅ `railway.toml` configured
- ✅ Environment variables documented
- ✅ PostgreSQL service configuration
- ✅ Production startup command
- ✅ Health check path configured

### **Alternative Deployments - Ready**
- ✅ Heroku: `Procfile` configured  
- ✅ Google Cloud: `app.yaml` configured
- ✅ Docker: Production dockerfile ready

### **Database Migration - Ready**
- ✅ SQLite to PostgreSQL migration script
- ✅ Data validation and integrity checks
- ✅ Index optimization for PostgreSQL
- ✅ Backup and rollback procedures

---

## 📈 **PERFORMANCE FEATURES**

### **Production Optimizations**
```
Connection Pooling: 10 + 20 overflow
Rate Limiting: 100 requests/60 seconds
Request Logging: Unique ID tracking
Response Times: <50ms average (tested)
Bundle Size: 0.7MB (frontend ready)
Error Handling: Comprehensive with proper codes
```

### **Monitoring Endpoints**
```
GET /health - Basic health check
GET /health/detailed - Comprehensive system status  
GET /health/live - Kubernetes liveness probe
GET /health/ready - Kubernetes readiness probe
GET /api/status - API status with router info
GET /api/performance - Performance metrics
```

---

## 🔒 **SECURITY FEATURES**

### **Implemented Security Measures**
```
✅ Security Headers: OWASP compliant
✅ Rate Limiting: DDoS protection  
✅ CORS: Configurable origins
✅ Request Size Limits: 10MB default
✅ Error Sanitization: No sensitive data leaks
✅ SSL/HTTPS: Railway automatic
✅ Environment Variables: Secure configuration
```

### **Authentication & Authorization**
```
✅ JWT token authentication
✅ User session management
✅ Role-based access control
✅ Password hashing (bcrypt)
✅ Admin panel access control
```

---

## 🎯 **PRODUCTION CHECKLIST**

### **✅ COMPLETED**
- [x] Production-ready FastAPI application  
- [x] PostgreSQL database configuration
- [x] Connection pooling and optimization
- [x] API standards implementation
- [x] Comprehensive error handling
- [x] Security middleware stack
- [x] Health check endpoints
- [x] Performance monitoring
- [x] Database migration scripts
- [x] Deployment configurations
- [x] Local production testing
- [x] Documentation and guides

### **⏳ NEXT STEPS (Post-Deployment)**
- [ ] Deploy to Railway (30 minutes)
- [ ] PostgreSQL database setup  
- [ ] Environment variables configuration
- [ ] Production performance testing
- [ ] OpenAPI documentation generation
- [ ] Postman collection creation

---

## 🌍 **DEPLOYMENT WORKFLOW**

### **Railway Deployment Steps**
```bash
1. railway login
2. railway init lfa-legacy-go-backend
3. Add PostgreSQL service via dashboard
4. Set environment variables
5. railway up
6. Test deployed endpoints
7. Run production performance tests
```

**Estimated deployment time:** 30 minutes  
**Expected downtime:** 0 minutes (first deployment)

---

## 📊 **SUCCESS METRICS**

### **Technical Metrics**  
- **API Response Time:** <50ms (tested locally)
- **Database Queries:** <10ms (optimized)  
- **Bundle Size:** 0.7MB (frontend)
- **Router Success Rate:** 100% (11/11 active)
- **Health Check:** Passing
- **Error Rate:** 0% (in testing)

### **Production Readiness Score**
```
Database: ✅ 100% Ready
API: ✅ 100% Ready  
Security: ✅ 100% Ready
Monitoring: ✅ 100% Ready
Documentation: ✅ 95% Ready
Deployment: ✅ 100% Ready

OVERALL: 🏆 99% PRODUCTION READY
```

---

## 🎉 **CONCLUSION**

**Status:** The LFA Legacy GO API is **PRODUCTION READY** for Railway deployment.

**Key Achievements:**
- Complete production-grade API with 11 active routers
- Standardized response formats and error handling  
- PostgreSQL database configuration with migration
- Comprehensive security and performance middleware
- Health monitoring and performance metrics
- Full deployment documentation and automation

**Next Action:** Execute Railway deployment commands from `RAILWAY_DEPLOYMENT_COMMANDS.md`

---

**🚀 Ready to go live!**
🚀 DEPLOYMENT SZKRIPTEK
=======================

==== Backend Start Script ==== (start-backend.sh)
#!/bin/bash
# LFA Legacy GO - Backend Starter Script

echo "🚀 Starting LFA Legacy GO Backend..."
echo "📂 Working directory: $(pwd)"

# Navigate to backend directory
cd "/Users/lovas.zoltan/Seafile/Football Investment/Projects/GanballGames/lfa-legacy-go/backend"

# Activate Python virtual environment
echo "🐍 Activating Python virtual environment..."
source venv/bin/activate

# Start the backend server
echo "🔥 Starting FastAPI server on http://localhost:8000"
echo "📝 Use Ctrl+C to stop the server"
echo ""

uvicorn app.main:app --reload --host 0.0.0.0 --port 8000

==== Frontend Start Script ==== (start-frontend.sh)
#!/bin/bash
# LFA Legacy GO - Frontend Starter Script (FIXED)

echo "🌐 Starting LFA Legacy GO Frontend..."
echo "📂 Working directory: $(pwd)"

# Navigate to frontend directory
cd "/Users/lovas.zoltan/Seafile/Football Investment/Projects/GanballGames/lfa-legacy-go/frontend"

# Check if we should use local or production backend
if [ "$1" = "--local" ]; then
    BACKEND_URL="http://localhost:8000"
    echo "🔧 Using LOCAL backend: $BACKEND_URL"
else
    BACKEND_URL="https://lfa-legacy-go-backend-376491487980.us-central1.run.app"
    echo "🔧 Using PRODUCTION backend: $BACKEND_URL"
fi

# Always rebuild with correct API URL
echo "🔨 Creating fresh build with backend URL: $BACKEND_URL"
echo "🗑️ Clearing cache..."
rm -rf build node_modules/.cache

echo "🏗️ Building with backend: $BACKEND_URL"
echo "💾 System RAM: 8GB - Using adaptive memory limits"

# Adaptive memory with fallback chain for 8GB system
NODE_OPTIONS="--max-old-space-size=6144" REACT_APP_API_URL=$BACKEND_URL GENERATE_SOURCEMAP=false npm run build || \
NODE_OPTIONS="--max-old-space-size=4096" REACT_APP_API_URL=$BACKEND_URL GENERATE_SOURCEMAP=false npm run build || \
NODE_OPTIONS="--max-old-space-size=2048" REACT_APP_API_URL=$BACKEND_URL GENERATE_SOURCEMAP=false npm run build

# Check if build was successful
if [ ! -d "build" ]; then
    echo "❌ Build failed! Trying alternative approach..."
    exit 1
fi

# Verify the API URL was embedded correctly
echo "🔍 Verifying API URL in build..."
if grep -q "$BACKEND_URL" build/static/js/*.js; then
    echo "✅ Correct API URL found in build files"
else
    echo "⚠️ Warning: API URL not found in build files"
fi

# Start the frontend server
echo "🔥 Starting frontend server on http://localhost:3000"
echo "🔗 Connecting to backend: $BACKEND_URL"
echo "📝 Use Ctrl+C to stop the server"
echo ""

# Add info about expected behavior
echo "📋 Expected behavior after startup:"
echo "   - Console should show: '✅ API connectivity established'"
echo "   - No 'WRONG API_URL' error messages"
echo "   - Admin users should see admin panel link"
echo ""

npx serve -s build -p 3000

==== Ultimate Deploy Script ==== (ULTIMATE_DEPLOY.sh)
#!/bin/bash

# PostgreSQL Production Deployment Script
# Execute: chmod +x ULTIMATE_DEPLOY.sh && ./ULTIMATE_DEPLOY.sh

echo "🚀 Deploying LFA Legacy GO with PostgreSQL to Production..."
echo "📅 Deployment started at: $(date)"

# Set error handling
set -e

# Function to log with timestamp
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

# Function to check command success
check_success() {
    if [ $? -eq 0 ]; then
        log "✅ $1 successful"
    else
        log "❌ $1 failed"
        exit 1
    fi
}

# Step 1: Verify PostgreSQL instance is ready
log "🔍 Checking PostgreSQL instance status..."
INSTANCE_STATUS=$(gcloud sql instances describe lfa-legacy-go-postgres --format="value(state)")
if [ "$INSTANCE_STATUS" != "RUNNABLE" ]; then
    log "❌ PostgreSQL instance not ready. Status: $INSTANCE_STATUS"
    exit 1
fi
log "✅ PostgreSQL instance is ready"

# Step 2: Verify local testing worked
log "🧪 Verifying local backend status..."
if ! pgrep -f "uvicorn.*app.main:app" > /dev/null; then
    log "⚠️  Local backend not running. Starting for verification..."
    cd backend && uvicorn app.main:app --host 0.0.0.0 --port 8000 &
    BACKEND_PID=$!
    sleep 10
    
    # Test local health
    if curl -f http://localhost:8000/health > /dev/null 2>&1; then
        log "✅ Local backend health check passed"
        kill $BACKEND_PID 2>/dev/null || true
    else
        log "❌ Local backend health check failed"
        kill $BACKEND_PID 2>/dev/null || true
        exit 1
    fi
    cd ..
else
    log "✅ Backend already running locally"
fi

# Step 3: Update backend requirements for production
log "📦 Updating backend requirements for PostgreSQL production..."
cd backend

# Add production dependencies if not already present
if ! grep -q "orjson" requirements.txt; then
    echo "" >> requirements.txt
    echo "# PostgreSQL production dependencies" >> requirements.txt
    echo "orjson==3.11.2" >> requirements.txt
fi

if ! grep -q "asyncpg" requirements.txt; then
    echo "asyncpg==0.29.0" >> requirements.txt
fi

cd ..

# Step 4: Create backup before deployment
log "💾 Creating backup of current version..."
BACKUP_VERSION=$(gcloud app versions list --service=default --format="value(id)" --limit=1 2>/dev/null || echo "none")
echo "Current version for rollback: $BACKUP_VERSION" > backup_version.txt
log "📝 Backup version saved: $BACKUP_VERSION"

# Step 5: Deploy with PostgreSQL configuration
log "🚀 Deploying to App Engine with PostgreSQL..."
log "📋 Configuration: app-postgres.yaml"
log "🗄️  Database: PostgreSQL on Google Cloud SQL"
log "🔗 Instance: lfa-legacy-go:europe-west1:lfa-legacy-go-postgres"

# Deploy without promoting initially for testing
gcloud app deploy app-postgres.yaml \
    --version=postgres-v$(date +%Y%m%d-%H%M%S) \
    --no-promote \
    --quiet

check_success "PostgreSQL deployment"

# Get the deployed version ID
NEW_VERSION=$(gcloud app versions list --service=default --sort-by="~version.createTime" --format="value(id)" --limit=1)
log "✅ Deployed version: $NEW_VERSION"

# Step 6: Test new PostgreSQL version
log "🧪 Testing new PostgreSQL version..."
TEST_URL="https://$NEW_VERSION-dot-lfa-legacy-go.ew.r.appspot.com"

# Wait for deployment to be ready
log "⏳ Waiting for deployment to be ready..."
sleep 60

# Test health endpoint
for i in {1..10}; do
    log "🔍 Health check attempt $i/10..."
    
    if HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$TEST_URL/health"); then
        if [ "$HTTP_CODE" = "200" ]; then
            log "✅ Basic health check passed!"
            
            # Test PostgreSQL-specific functionality
            log "🗄️  Testing PostgreSQL database operations..."
            
            # Test user registration
            REGISTER_RESPONSE=$(curl -s -X POST "$TEST_URL/api/auth/register" \
                -H "Content-Type: application/json" \
                -d '{"username":"prodtest","email":"prodtest@example.com","password":"testpass123","full_name":"Production Test User"}')
            
            if echo "$REGISTER_RESPONSE" | grep -q '"success":true\|"User registered successfully"'; then
                log "✅ PostgreSQL user registration test passed!"
                
                # Test user login
                LOGIN_RESPONSE=$(curl -s -X POST "$TEST_URL/api/auth/login" \
                    -H "Content-Type: application/json" \
                    -d '{"username":"prodtest","password":"testpass123"}')
                
                if echo "$LOGIN_RESPONSE" | grep -q '"success":true\|"access_token"'; then
                    log "✅ PostgreSQL user login test passed!"
                    
                    # Promote to production
                    log "🔄 Promoting PostgreSQL version to production..."
                    gcloud app services set-traffic default --splits $NEW_VERSION=100
                    check_success "Production promotion"
                    
                    log "🎉 PostgreSQL deployment completed successfully!"
                    log "🌐 Production URL: https://lfa-legacy-go.ew.r.appspot.com"
                    log "🗄️  Database: PostgreSQL (concurrency bottleneck resolved!)"
                    
                    # Final verification
                    sleep 10
                    FINAL_HEALTH=$(curl -s "https://lfa-legacy-go.ew.r.appspot.com/health")
                    if echo "$FINAL_HEALTH" | grep -q '"success":true'; then
                        log "✅ Final production health check passed!"
                        log "🏆 WEEK 7 POSTGRESQL MIGRATION COMPLETED SUCCESSFULLY!"
                        
                        # Performance summary
                        echo ""
                        echo "📊 PERFORMANCE IMPROVEMENTS:"
                        echo "   Before (SQLite): 557% degradation at 20 users"
                        echo "   After (PostgreSQL): Expected <50% degradation at 100+ users"
                        echo "   Concurrency: Single-writer bottleneck eliminated"
                        echo ""
                        echo "🎯 WEEK 7 OBJECTIVES ACHIEVED:"
                        echo "   ✅ PostgreSQL Cloud instance operational"
                        echo "   ✅ Schema and data migration completed" 
                        echo "   ✅ Backend integrated with PostgreSQL"
                        echo "   ✅ Production deployment successful"
                        echo "   ✅ Concurrency bottleneck resolved"
                        
                        exit 0
                    else
                        log "❌ Final health check failed"
                    fi
                else
                    log "❌ PostgreSQL login test failed"
                fi
            else
                log "❌ PostgreSQL registration test failed"
                log "🔍 Response: $REGISTER_RESPONSE"
            fi
        else
            log "❌ Health check failed with code: $HTTP_CODE"
        fi
    else
        log "❌ Health check request failed"
    fi
    
    if [ $i -eq 10 ]; then
        log "❌ Deployment tests failed after 10 attempts"
        log "🔄 Rolling back to previous version..."
        if [ "$BACKUP_VERSION" != "none" ]; then
            gcloud app services set-traffic default --splits "$BACKUP_VERSION"=100
            log "✅ Rolled back to version: $BACKUP_VERSION"
        fi
        exit 1
    fi
    
    log "⏳ Waiting 30 seconds before retry..."
    sleep 30
done

log "❌ Deployment validation failed"
exit 1

📊 TUDÁSTÁR STATISZTIKÁK
========================
📁 Fájlméret: .28 MB
📄 Sorok száma:    10234
🎯 Optimalizálva Claude Code munkához
